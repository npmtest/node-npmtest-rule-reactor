{"/home/travis/build/npmtest/node-npmtest-rule-reactor/test.js":"/* istanbul instrument in package npmtest_rule_reactor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rule-reactor/lib.npmtest_rule_reactor.js":"/* istanbul instrument in package npmtest_rule_reactor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_rule_reactor = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_rule_reactor = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-rule-reactor/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-rule-reactor && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_rule_reactor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_rule_reactor\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_rule_reactor.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_rule_reactor.rollup.js'] =\n            local.assetsDict['/assets.npmtest_rule_reactor.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_rule_reactor.__dirname + '/lib.npmtest_rule_reactor.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rule-reactor/node_modules/rule-reactor/index.js":"/* MIT License\n\nrule-reactor: A light weight, fast, expressive forward chaining business rule engine leveraging JavaScript internals and Functions as objects rather than Rete.\n\nCopyright (c) 2016 Simon Y. Blackwell\n\n*/\n\nvar uuid = require(\"uuid\");\n//var hamsters = require(\"webhamsters/src/hamsters\");\n//var Parallel = require(\"paralleljs\");\n\n(function() {\n\t\"use strict\";\n\t\n\tvar domains = global;\n\t\n\tfunction intersector(objects) {\n\t\treturn function intersection() {\n\t\t\tvar min = Infinity, // length of shortest array argument\n\t\t\t\tshrtst = 0, // index of shortest array argument\n\t\t\t\tset = (objects ? new Set() : {}),\n\t\t\t\trslt = [], // result\n\t\t\t\tmxj = arguments.length-1;\n\t\t\tfor(var j=0;j<=mxj;j++) { // find index of shortest array argument\n\t\t\t\tvar l = arguments[j].length;\n\t\t\t\tif(l<min) {\n\t\t\t\t\tshrtst = j;\n\t\t\t\t\tmin = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar shrt = arguments[shrtst],\n\t\t\t\tmxi = shrt.length;\n\t\t\tfor(var i=0;i<mxi;i++) { // initialize set of possible values from shortest array\n\t\t\t\tif(objects) { set.add(shrt[i]); } else { set[shrt[i]]=1; }\n\t\t\t}\n\t\t\tfor(var j=0;j<=mxj;j++) { // loop through all array arguments\n\t\t\t\tvar\tarray = arguments[j],\n\t\t\t\t\tmxk = array.length;\n\t\t\t\tfor(var k=0;k<mxk;k++) { // loop through all values\n\t\t\t\t\tvar item = array[k];\n\t\t\t\t\tif((objects && set.has(item)) || set[item]) { // if value is possible\n\t\t\t\t\t\tif(j===mxj) { // and all arrays have it (or we would not be at this point)\n\t\t\t\t\t\t\trslt.push(item); // add to results\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rslt;\n\t\t};\n\t}\n\tvar intersection = intersector(false);\n\t\n//\t\tportions from http://phrogz.net/lazy-cartesian-product\n\tfunction CXProduct(collections){\n\t\tvar me = this;\n\t\tme.collections = (collections ? collections : []);\n\t}\n\tCXProduct.prototype.length = function() {\n\t\tvar me = this;\n\t\tif(me.collections.length===0) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar size = 1;\n\t\tthis.collections.forEach(function(collection) { size *= collection.length; });\n\t\tif(typeof(me.start)===\"number\") {\n\t\t\tif(typeof(me.end)===\"number\") {\n\t\t\t\treturn me.end - me.start;\n\t\t\t}\n\t\t\treturn size - me.start;\n\t\t}\n\t\treturn size; \n\t};\n\tCXProduct.prototype.length.size = CXProduct.prototype.length;\n\tCXProduct.prototype.every = function(callback,pattern) {\n\t\tfunction dive(cxproduct,d,counter,collections,lens,p,callback,pattern){\n\t\t\tvar a=collections[d], max=collections.length-1,len=lens[d];\n\t\t\tif (d===max) {\n\t\t\t\tfor (var i=0;i<len;++i) { \n\t\t\t\t\tp[d]=a[i]; \n\t\t\t\t\tif(!callback(p.slice(0),counter.count)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tcounter.count++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var j=0;j<len;++j) {\n\t\t\t\t\tp[d]=a[j];\n\t\t\t\t\tdive(cxproduct,d+1,counter,collections,lens,p,callback,pattern);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.pop();\n\t\t}\n\t\tif(typeof(start)===\"number\") {\n\t\t\treturn this.some2(callback,pattern);\n\t\t}\n\t\tvar me = this, p=[],lens=[];\n\t\tfor (var i=me.collections.length;i--;) { lens[i]=me.collections[i].length; }\n\t\tif(dive(me,0,{count:0},me.collections,lens,p,callback,pattern)!==false) {\n\t\t\treturn true;\n\t\t}\n\t};\n\tCXProduct.prototype.get = function(index,pattern){\n\t\tfunction get(n,collections,dm,c) {\n\t\t\tfor (var i=collections.length;i--;) { c[i]=collections[i][(n/dm[i][0]<<0)%dm[i][1]]; }\n\t\t}\n\t\tvar me = this, dm = [], c = [];\n\t\tfor (var f=1,l,i=me.collections.length;i--;f*=l) { dm[i]=[f,l=me.collections[i].length];  }\n\t\tif(index>=me.length()) {\n\t\t\treturn; // undefined\n\t\t}\n\t\tget(index,me.collections,dm,c);\n\t\tif(!pattern || pattern.every(function(value,i) {\n\t\t\treturn typeof(value)===\"undefined\" || (typeof(value)===\"function\" ? value.call(c,c[i],i) : false) || c[i]===value;\n\t\t})) {\n\t\t\treturn c.slice(0);\n\t\t}\n\t}\n\tCXProduct.prototype.some = function(callback,pattern) {\n\t\tfunction dive(cxproduct,d,counter,collections,lens,p,callback,pattern){\n\t\t\tvar a=collections[d], max=collections.length-1,len=lens[d];\n\t\t\tif (d===max) {\n\t\t\t\tfor (var i=0;i<len;++i) { \n\t\t\t\t\tp[d]=a[i]; \n\t\t\t\t\tif(callback(p.slice(0),counter.count)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcounter.count++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var j=0;j<len;++j) {\n\t\t\t\t\tp[d]=a[j];\n\t\t\t\t\tdive(cxproduct,d+1,counter,collections,lens,p,callback,pattern);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.pop();\n\t\t}\n\t\tif(typeof(start)===\"number\") {\n\t\t\treturn this.some2(callback,pattern);\n\t\t}\n\t\tvar me = this, p=[],lens=[];\n\t\tfor (var i=me.collections.length;i--;) { lens[i]=me.collections[i].length; }\n\t\treturn dive(me,0,{count:0},me.collections,lens,p,callback,pattern);\n\t}\n\tCXProduct.prototype.some2 = function(callback,pattern) {\n\t\tvar me = this, i = 0, value, max = me.length();\n\t\tdo {\n\t\t\tvalue = me.get(i);\n\t\t\tif(typeof(value)!==\"undefined\" && (!callback || callback(value)) && (!pattern || me.testpattern(pattern,value))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ti++;\n\t\t} while(i<max); \n\t\treturn false;\n\t}\n\tCXProduct.prototype.verify = function(i,row) {\n\t\tvar me = this;\n\t\tvar match = me.get(i);\n\t\treturn match && match.every(function(element,i) { return element===row[i]; });\n\t}\n\tCXProduct.prototype.forEach1 = function(callback) {\n\t\tfunction dive(cxproduct,d,counter,collections,lens,p,callback){\n\t\t\tvar a=collections[d], max=collections.length-1,len=lens[d];\n\t\t\tif (d===max) {\n\t\t\t\tfor (var i=0;i<len;++i) { \n\t\t\t\t\tp[d]=a[i]; \n\t\t\t\t\tcallback(p.slice(0),counter.count); \n\t\t\t\t\tcounter.count++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var j=0;j<len;++j) {\n\t\t\t\t\tp[d]=a[j];\n\t\t\t\t\tdive(cxproduct,d+1,counter,collections,lens,p,callback);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.pop();\n\t\t}\n\t\tif(typeof(start)===\"number\") {\n\t\t\tthis.forEach2(callback);\n\t\t\treturn;\n\t\t}\n\t\tvar me = this, p=[],lens=[];\n\t\tfor (var i=me.collections.length;i--;) { lens[i]=me.collections[i].length; }\n\t\tdive(me,0,{count:0},me.collections,lens,p,callback);\n\t}\n\tCXProduct.prototype.forEach2 = function(callback) {\n\t\tvar me = this, i = (typeof(me.start)===\"number\" ? me.start : 0), max = (typeof(me.end)===\"number\" ? me.end : me.length());\n\t\twhile(i<max) {\n\t\t\tvar value = me.get(i);\n\t\t\tif(typeof(value)!==\"undefined\") {\n\t\t\t\tcallback(value);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tCXProduct.prototype.forEach = CXProduct.prototype.forEach1;//\tportions from http://phrogz.net/lazy-cartesian-product\n\t\n\t\n\tfunction getFunctionArgs(f) {\n\t\tvar str = f+\"\";\n\t\tvar start = str.indexOf(\"(\")+1;\n\t\tvar end = str.indexOf(\")\");\n\t\tvar result = str.substring(start,end).split(\",\");\n\t\tresult.forEach(function(arg,i) {\n\t\t\tresult[i] = arg.trim();\n\t\t});\n\t\tif(result.length===1 && result[0]===\"\") {\n\t\t\treturn [];\n\t\t}\n\t\treturn result;\n\t}\n\tfunction compile(reactor,rule,boost) {\n\t\tvar variables = Object.keys(rule.domain);\n\t\tvariables.forEach(function(variable) {\n\t\t\tvar cons = rule.domain[variable];\n\t\t\tif(typeof(cons)!==\"function\") {\n\t\t\t\tthrow new TypeError(\"Domain variable \" + variable + \" is not a constructor in rule \" + rule.name);\n\t\t\t}\n\t\t\tif(!cons.name || cons.name.length===0 || cons.name===\"anonymous\") {\n\t\t\t\tthrow new TypeError(\"Constructor for domain variable \" + variable + \" in rule \" + rule.name + \" must have a name.\");\n\t\t\t}\n\t\t\tif(!rule.reactor.domain[cons.name]) {\n\t\t\t\trule.reactor.domain[cons.name] = cons;\n\t\t\t}\n\t\t\t//cons.instances = (cons.instances ? cons.instances : []);\n\t\t\t//cons.index = (cons.index ? cons.index : {});\n\t\t\t// below fixes issue #21, thanks @zelgadis87\n\t\t\tif ( !cons.hasOwnProperty('instances') ) cons.instances = [];\n\t\t\tif ( !cons.hasOwnProperty('index') ) cons.index = {};\n\t\t\tcons.prototype.rules = (cons.prototype.rules ? cons.prototype.rules : {});\n\t\t\tcons.prototype.rules[rule.name] = rule;\n\t\t\tcons.prototype.activeKeys = (cons.prototype.activeKeys ? cons.prototype.activeKeys : {});\n\t\t\tcons.exists = function(f) {\n\t\t\t\tf = (f ? f : function() { return true; });\n\t\t\t\treturn cons.instances && cons.instances.some(function(instance) {\n\t\t\t\t\treturn f(instance);\n\t\t\t\t});\n\t\t\t};\n\t\t\tcons.forAll = function(f) {\n\t\t\t\treturn cons.instances && cons.instances.every(function(instance) {\n\t\t\t\t\treturn f(instance);\n\t\t\t\t});\n\t\t\t};\n\t\t\trule.range[variable] = {};\n\t\t\trule.bindings[variable] = (rule.bindings[variable] ? rule.bindings[variable] : []);\n\t\t\t// extract instance keys from condition using a side-effect of replace\n\t\t\trule.conditions.forEach(function(condition) {\n\t\t\t\t(condition+\"\").replace(new RegExp(\"(\\\\b\"+variable+\"\\\\.\\\\w+\\\\b)\",\"g\"),\n\t\t\t\t\tfunction(match) { \n\t\t\t\t\t\tvar parts = match.split(\".\"),key = parts[1];\n\t\t\t\t\t\t// cache reactive non-function keys on class prototype\n\t\t\t\t\t\tif(key.indexOf(\"(\")===-1) {\n\t\t\t\t\t\t\tcons.prototype.activeKeys[key] = true;\n\t\t\t\t\t\t\t// cache what keys are associated with what variables\n\t\t\t\t\t\t\trule.range[variable][key] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// don't really do a replace!\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t\tif(variables.length>0) {\n\t\t\trule.triggers.push({domain:rule.domain,range:rule.range});\n\t\t}\n\t\trule.conditions.forEach(function(condition) {\n\t\t\t(condition+\"\").replace(/exists\\(\\s*(\\s*{.*\\s*})\\s*,\\s*(.*)\\s*\\)/g,\n\t\t\t\tfunction(match,domainstr,conditionstr) {\n\t\t\t\t\tvar domain = new Function(\"return \" + domainstr)(),\n\t\t\t\t\t\tvariables = Object.keys(domain),\n\t\t\t\t\t\tquantification = {domain: domain, range: {}};\n\t\t\t\t\trule.triggers.push(quantification);\n\t\t\t\t\tvariables.forEach(function(variable) {\n\t\t\t\t\t\tvar cons = domain[variable];\n\t\t\t\t\t\tif(!rule.reactor.domain[cons.name]) {\n\t\t\t\t\t\t\trule.reactor.domain[cons.name] = cons;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tquantification.range[variable] = (quantification.range[variable] ? quantification.range[variable] : {});\n\t\t\t\t\t\tcons.prototype.rules = (cons.prototype.rules ? cons.prototype.rules : {});\n\t\t\t\t\t\tcons.prototype.rules[rule.name] = rule;\n\t\t\t\t\t\tcons.prototype.activeKeys = (cons.prototype.activeKeys ? cons.prototype.activeKeys : {});\n\t\t\t\t\t\tconditionstr.replace(new RegExp(\"(\\\\b\"+variable+\"\\\\.\\\\w+\\\\b)\",\"g\"),\n\t\t\t\t\t\t\tfunction(match) { \n\t\t\t\t\t\t\t\tvar parts = match.split(\".\"),key = parts[1];\n\t\t\t\t\t\t\t\t// cache reactive non-function keys on class prototype\n\t\t\t\t\t\t\t\tif(key.indexOf(\"(\")===-1) {\n\t\t\t\t\t\t\t\t\tcons.prototype.activeKeys[key] = true;\n\t\t\t\t\t\t\t\t\t// cache what keys are associated with what variables\n\t\t\t\t\t\t\t\t\tquantification.range[variable][key] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// don't really do a replace!\n\t\t\t\t\t\t\t\treturn match;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\t// don't really do a replace!\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t);\n\t\t\t(condition+\"\").replace(/forAll\\(\\s*(\\s*{.*\\s*})\\s*,\\s*(.*)\\s*\\)/g,\n\t\t\t\t\tfunction(match,domainstr,conditionstr) {\n\t\t\t\t\t\tvar domain = new Function(\"return \" + domainstr)(), variables = Object.keys(domain);\n\t\t\t\t\t\tvar quantification = {domain: domain, range: {}};\n\t\t\t\t\t\trule.triggers.push(quantification);\n\t\t\t\t\t\tvariables.forEach(function(variable) {\n\t\t\t\t\t\t\tvar cons = domain[variable];\n\t\t\t\t\t\t\tif(!rule.reactor.domain[cons.name]) {\n\t\t\t\t\t\t\t\trule.reactor.domain[cons.name] = cons;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquantification.range[variable] = (quantification.range[variable] ? quantification.range[variable] : {});\n\t\t\t\t\t\t\tcons.prototype.rules = (cons.prototype.rules ? cons.prototype.rules : {});\n\t\t\t\t\t\t\tcons.prototype.rules[rule.name] = rule;\n\t\t\t\t\t\t\tcons.prototype.activeKeys = (cons.prototype.activeKeys ? cons.prototype.activeKeys : {});\n\t\t\t\t\t\t\tconditionstr.replace(new RegExp(\"(\\\\b\"+variable+\"\\\\.\\\\w+\\\\b)\",\"g\"),\n\t\t\t\t\t\t\t\tfunction(match) { \n\t\t\t\t\t\t\t\t\tvar parts = match.split(\".\"),key = parts[1];\n\t\t\t\t\t\t\t\t\t// cache reactive non-function keys on class prototype\n\t\t\t\t\t\t\t\t\tif(key.indexOf(\"(\")===-1) {\n\t\t\t\t\t\t\t\t\t\tcons.prototype.activeKeys[key] = true;\n\t\t\t\t\t\t\t\t\t\t// cache what keys are associated with what variables\n\t\t\t\t\t\t\t\t\t\tquantification.range[variable][key] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// don't really do a replacereactornt!\n\t\t\t\t\t\t\t\t\treturn match;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// don't really do a replacereactornt!\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t});\n\t\trule.compiledConditions = [];\n\t\trule.conditions.forEach(function(condition,i) {\n\t\t\tif((condition+\"\").indexOf(\"return\")===-1) {\n\t\t\t\tthrow new TypeError(\"Condition function missing a return statereactornt in rule '\" + rule.name + \"' condition \" + i);\n\t\t\t}\n\t\t\tvar args = getFunctionArgs(condition);\n\t\t\tcondition.required = new Array(args.length);\n\t\t\targs.forEach(function(arg,j) {\n\t\t\t\tvar required = variables.indexOf(arg);\n\t\t\t\tif(required===-1) {\n\t\t\t\t\tthrow new ReferenceError(\"Referenced domain variable '\" + arg + \"' undefined in rule '\" + rule.name + \"' condition \",i);\n\t\t\t\t}\n\t\t\t\tcondition.required[j] = required;\n\t\t\t});\n\t\t\tif(!boost) {\n\t\t\t\trule.compiledConditions.push(function(match) {\n\t\t\t\t\tvar reactor = this, args = [];\n\t\t\t\t\t// no required = domainless\n\t\t\t\t\tif(!condition.required || condition.required.every(function(i) {\n\t\t\t\t\t\tif(typeof(match[i])!==\"undefined\") {\n\t\t\t\t\t\t\treturn args.push(match[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t})) {\n\t\t\t\t\t\treturn condition.apply(reactor,args);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar required = (condition.required ? condition.required : []);\n\t\t\t\tvar f = new Function(\"match\",\"var args = [];if(\" + JSON.stringify(required) + \".every(function(i,j,required){if(match[i]!==undefined){return args.push(match[i]);}})) {return (\" + condition + \").apply(undefined,args);}\");\n\t\t\t\trule.compiledConditions.push(f);\n\t\t\t}\n\t\t});\n\t\tvar args = getFunctionArgs(rule.action);\n\t\trule.action.required = new Array(args.length);\n\t\targs.forEach(function(arg,i) {\n\t\t\tvar required = variables.indexOf(arg);\n\t\t\tif(required===-1) {\n\t\t\t\tthrow new ReferenceError(\"Referenced domain variable '\" + arg + \"' undefined in rule '\" + rule.name + \"' action\");\n\t\t\t}\n\t\t\trule.action.required[i] = required;\n\t\t\t\n\t\t});\n\t\t// do not add full compilation since actions are allowed to use closure scope and it will break that\n\t\trule.compiledAction = function(match) {\n\t\t\tvar reactor = this, args = [];\n\t\t\t// no required = domainless\n\t\t\tif(!rule.action.required || rule.action.required.every(function(i) {\n\t\t\t\tif(typeof(match[i])!==\"undefined\") {\n\t\t\t\t\treturn args.push(match[i]);\n\t\t\t\t}\n\t\t\t})) {\n\t\t\t\trule.action.apply(reactor,args);\n\t\t\t}\n\t\t};\n\t}\n\n\t// dummy console so logging can easily be retractd\n\tvar Console = {};\n\tConsole.log = function() { \n\t\tvar c = console;\n\t\tc.log.apply(console,arguments); \n\t};\n\t// uncomment line below to stop logging\n\t//Console.log = function() {};\n\t\n\t// http://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers\n\tfunction insertSorted(arr, item, comparator) {\n\t\tif (comparator == null) {\n\t\t\t// emulate the default Array.sort() comparator\n\t\t\tcomparator = function(a, b) {\n\t\t\t\tif (typeof a !== \"string\") { a = String(a); }\n\t\t\t\tif (typeof b !== \"string\") { b = String(b); }\n\t\t\t\treturn (a > b ? 1 : (a < b ? -1 : 0));\n\t\t\t};\n\t\t}\n\t\t// get the index we need to insert the item at\n\t\tvar min = 0;\n\t\tvar max = arr.length;\n\t\tvar index = Math.floor((min + max) / 2);\n\t\twhile (max > min) {\n\t\t\tif (comparator(item, arr[index]) < 0) {\n\t\t\t\tmax = index;\n\t\t\t} else {\n\t\t\t\tmin = index + 1;\n\t\t\t}\n\t\t\tindex = Math.floor((min + max) / 2);\n\t\t}\n\t\t// insert the item\n\t\tarr.splice(index, 0, item);\n\t}\n\n\tfunction Activation(rule,match,index,bindings,instance) {\n\t\tvar me = this;\n\t\tme.timestamp = new Date();\n\t\tme.rule = rule;\n\t\tme.match = match;\n\t\tme.index = index;\n\t\tme.bindings = bindings;\n\t\tme.instance = instance;\n\t\tme.rule.activated++;\n\t\tinsertSorted(me.rule.reactor.agenda,me,function(a,b) { return (a.rule.salience > b.rule.salience ? 1 : (a.rule.salience < b.rule.salience ? -1 : 0)); });\n\t\tvar activations = rule.activations.get(instance);\n\t\tif(!activations) {\n\t\t\tactivations = [];\n\t\t}\n\t\tactivations.push(me);\n\t\trule.activations.set(instance,activations);\n\t\tif(me.rule.reactor.tracelevel>1) {\n\t\t\tConsole.log(\"Activating: \",rule,match);\n\t\t}\n\t}\n\tActivation.prototype.cancel = function() {\n\t\tthis.cancelled = true;\n\t}\n\tActivation.prototype.execute = function(index) {\n\t\tvar me = this;\n\t\t// re-test just in-case\n\t\tme.delete(undefined,index,true);\n\t\tif(!me.cancelled && (!me.bindings || me.bindings.verify(me.index,me.match)) && me.rule.compiledConditions.every(function(condition) {\n\t\t\treturn condition.call(me,me.match);\n\t\t})) {\n\t\t\tme.rule.fire(me.match);\n\t\t}\n\t}\n\tActivation.prototype.delete = function(instance,index,supresslog) {\n\t\tvar me = this, i;\n\t\tif(!instance || me.match.indexOf(instance)>=0) {\n\t\t\tif(!supresslog && me.rule.reactor.tracelevel>1) {\n\t\t\t\tConsole.log(\"Deactivating: \",me.rule,me.match);\n\t\t\t}\n\t\t\tvar activations = me.rule.activations.get(instance);\n\t\t\tif(activations) {\n\t\t\t\ti = activations.indexOf(me);\n\t\t\t\tif(i>=0) {\n\t\t\t\t\tactivations.splice(i,1);\n\t\t\t\t\tif(activations.length===0) {\n\t\t\t\t\t\tme.rule.activations.delete(instance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(typeof(index)!==\"undefined\") {\n\t\t\t\tif(index===me.rule.reactor.agenda.length-1) {\n\t\t\t\t\tme.rule.reactor.agenda.pop();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tme.rule.reactor.agenda.splice(index,1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ti = me.rule.reactor.agenda.indexOf(me);\n\t\t\tif(i>=0) {\n\t\t\t\tme.rule.reactor.agenda.splice(i,1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction Rule(reactor,name,salience,domain,condition,action,boost) {\n\t\tvar me = this;\n\t\tme.boost = boost;\n\t\tme.name = name;\n\t\tme.reactor = reactor;\n\t\tif(typeof(salience)!==\"number\") {\n\t\t\tthrow new TypeError(\"Salience \" + salience + \" is not a number in rule \" + name);\n\t\t}\n\t\tme.salience = salience;\n\t\tme.domain = domain;\n\t\tif(typeof(domain)!==\"object\") {\n\t\t\tthrow new TypeError(\"Domain \" + domain + \" is not an object in rule \" + name);\n\t\t}\n\t\tme.range = {};\n\t\tme.triggers = [];\n\t\tme.conditions = (Array.isArray(condition) || condition instanceof Array ? condition : [condition]);\n\t\tme.pattern = new Array(Object.keys(domain).length);\n\t\tif(typeof(action)!==\"function\") {\n\t\t\tthrow new TypeError(\"Action \" + action + \" is not a function in rule \" + name);\n\t\t}\n\t\tme.action = action;\n\t\tme.bindings = {};\n\t\tme.activations = new Map();\n\t\tme.potentialMatches = 0;\n\t\tme.tested = 0;\n\t\tme.activated = 0;\n\t\tme.fired = 0;\n\t\tcompile(reactor,me,me.boost);\n\t\tif(me.reactor.tracelevel>2) {\n\t\t\tConsole.log(\"New Rule: \",me);\n\t\t}\n\t\tme.bindInstances(true);\n\t} \n\tRule.prototype.bind = function(instance,test) {\n\t\tvar me = this, variables = Object.keys(me.bindings);\n\t\tvariables.map(function(variable) {\n\t\t\tif(instance instanceof me.domain[variable] && me.bindings[variable].indexOf(instance)===-1) {\n\t\t\t\tif(me.reactor.tracelevel>2) {\n\t\t\t\t\tConsole.log(\"Binding: \",me,variable,instance);\n\t\t\t\t}\n\t\t\t\tme.bindings[variable].push(instance);\n\t\t\t}\n\t\t});\n\t\tif(test) {\n\t\t\treturn me.test(instance);\n\t\t}\n\t}\n\tRule.prototype.bindInstances = function(test) {\n\t\tvar me = this, variables = Object.keys(me.domain);\n\t\tvariables.forEach(function(variable) {\n\t\t\tme.domain[variable].instances.forEach(function(instance) {\n\t\t\t\tme.bind(instance,test);\n\t\t\t});\n\t\t});\n\t}\n\tRule.prototype.delete = function() {\n\t\tvar me = this, variables = Object.keys(me.domain);\n\t\tvariables.forEach(function(variable) {\n\t\t\tvar cons = me.domain[variable];\n\t\t\tdelete cons.prototype.rules[me.name];\n\t\t});\n\t}\n\tRule.prototype.fire = function(match) {\n\t\tvar me = this;\n\t\tif(me.reactor.tracelevel>0) {\n\t\t\tConsole.log(\"Firing: \",this,match);\n\t\t}\n\t\tthis.fired++;\n\t\tthis.reactor.run.executions++;\n\t\tthis.compiledAction(match);\n\t}\n\tRule.prototype.test = function(instance,key) {\n\t\tvar me = this, variables = Object.keys(me.domain), result = false, values = [];\n\t\tif(!variables.every(function(variable) {\n\t\t\tvalues.push(me.bindings[variable]);\n\t\t\treturn me.bindings[variable].length>0;\n\t\t})) {\n\t\t\tme.cxproduct = null;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(!me.cxproduct) {\n\t\t\tme.cxproduct = new CXProduct(values);\n\t\t}\n\t\tif(me.reactor.tracelevel>2) {\n\t\t\tConsole.log(\"Testing: \",me,instance,key);\n\t\t}\n\t\tme.tested++;\n\t\tvar test = function (match,i) {\n\t\t\tif(me.compiledConditions.every(function(condition) {\n\t\t\t\treturn condition.call(me,match);\n\t\t\t})) {\n\t\t\t\tnew Activation(me,match,i,me.cxproduct,instance);\n\t\t\t\tresult = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif(variables.length===0) {\n\t\t\tif(test()) {\n\t\t\t\tresult = true;\n\t\t\t} else {\n\t\t\t\tme.reset(instance);\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t} else {\n\t\t\tme.potentialMatches = Math.max(me.potentialMatches,me.cxproduct.length());\n\t\t\tif(instance) {\n\t\t\t\tvariables.forEach(function(variable,i) {\n\t\t\t\t\tvar collections = me.cxproduct.collections.slice(0);\n\t\t\t\t\tif(instance instanceof me.domain[variable]) {\n\t\t\t\t\t\tcollections[i] = [instance];\n\t\t\t\t\t\tvar cxproduct = new CXProduct(collections);\n\t\t\t\t\t\ttest = function (match,i) {\n\t\t\t\t\t\t\tif(me.compiledConditions.every(function(condition) {\n\t\t\t\t\t\t\t\treturn condition.call(me,match);\n\t\t\t\t\t\t\t})) {\n\t\t\t\t\t\t\t\tnew Activation(me,match,i,cxproduct,instance);\n\t\t\t\t\t\t\t\tresult = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcxproduct.forEach(test);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tme.cxproduct.forEach(test);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tRule.prototype.reset = function(instance) {\n\t\tvar me = this;\n\t\tif(me.reactor.tracelevel>2) {\n\t\t\tConsole.log(\"Reseting: \",me,instance);\n\t\t}\n\t\tme.activations.forEach(function(activations,activator) {\n\t\t\tif(!instance || activator===instance) {\n\t\t\t\tactivations.forEach(function(activation) {\n\t\t\t\t\tvar i = me.reactor.agenda.indexOf(activation);\n\t\t\t\t\tif(i>=0) {\n\t\t\t\t\t\tme.reactor.agenda.splice(i,1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}\n\t\t});\n\t}\n\t\n\tRule.prototype.unbind = function(instance) {\n\t\tvar me = this, variables = Object.keys(me.bindings);\n\t\tvariables.map(function(variable) {\n\t\t\tif(instance instanceof me.domain[variable]) {\n\t\t\t\tvar i = me.bindings[variable].indexOf(instance);\n\t\t\t\tif(i>=0) {\n\t\t\t\t\tif(me.reactor.tracelevel>2) {\n\t\t\t\t\t\tConsole.log(\"Unbinding: \",me,variable,instance);\n\t\t\t\t\t}\n\t\t\t\t\tme.bindings[variable].splice(i,1);\n\t\t\t\t\tif(me.bindings[variable].length===0) {\n\t\t\t\t\t\tme.cxproduct = null;\n\t\t\t\t\t}\n\t\t\t\t\tme.reset(instance);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction indexObject(index,instance) {\n\t\tvar keys, primitive = false;\n\t\tif(instance instanceof Number || instance instanceof String || instance instanceof Boolean) {\n\t\t\tkeys = [\"value\"];\n\t\t\tprimitive = true;\n\t\t} else {\n\t\t\tkeys = Object.keys(instance);\n\t\t}\t\n\t\tkeys.forEach(function(key) {\n\t\t\tindex[key] = (index[key] ? index[key] : {});\n\t\t\tvar value = (primitive ? instance.valueOf() : instance[key]), type = typeof(value), valuekey, typekey;\n\t\t\tif(type===\"object\" && value) {\n\t\t\t\tif(typeof(value.__rrid__)===\"undefined\") {\n\t\t\t\t\tObject.defineProperty(value,\"__rrid__\",{value:uuid.v4()});\n\t\t\t\t}\n\t\t\t\tvaluekey = value.constructor.name + \"@\" + value.__rrid__;\n\t\t\t} else {\n\t\t\t\tvaluekey = value;\n\t\t\t}\n\t\t\tif(value===null || typeof(value)===\"undefined\") {\n\t\t\t\ttypekey = \"undefined\";\n\t\t\t} else {\n\t\t\t\ttypekey = type;\n\t\t\t}\n\t\t\tindex[key][valuekey] = (index[key][valuekey] ? index[key][valuekey] : {});\n\t\t\tindex[key][valuekey][typekey] = (index[key][valuekey][typekey] ? index[key][valuekey][typekey] : {});\n\t\t\tindex[key][valuekey][typekey][instance.__rrid__] = instance;\n\t\t});\n\t}\n\tfunction updateIndex(index,instance,key,oldValue) {\n\t\tif(typeof(instance[key])===\"undefined\" && !index[key]) { return; }\n\t\tindex[key] = (index[key] ? index[key] : {});\n\t\tvar value = instance[key], type = typeof(value), oldtype = typeof(oldValue), oldvaluekey, oldtypekey, valuekey, typekey;\n\t\tif(type===\"object\" && value) {\n\t\t\tif(typeof(value.__rrid__)===\"undefined\") {\n\t\t\t\tObject.defineProperty(value,\"__rrid__\",{value:uuid.v4()});\n\t\t\t}\n\t\t\tvaluekey = value.constructor.name + \"@\" + value.__rrid__;\n\t\t} else {\n\t\t\tvaluekey = value;\n\t\t}\n\t\tif(value===null || typeof(value)===\"undefined\") {\n\t\t\ttypekey = \"undefined\";\n\t\t} else {\n\t\t\ttypekey = type;\n\t\t}\n\t\tif(oldtype===\"object\" && oldValue) {\n\t\t\toldvaluekey = oldValue.constructor.name + \"@\" + oldValue.__rrid__;\n\t\t} else {\n\t\t\toldvaluekey = oldValue;\n\t\t}\n\t\tif(value===null || typeof(value)===\"undefined\") {\n\t\t\ttypekey = \"undefined\";\n\t\t} else {\n\t\t\ttypekey = type;\n\t\t}\n\t\tif(oldValue===null || typeof(oldValue)===\"undefined\") {\n\t\t\toldtypekey = \"undefined\";\n\t\t} else {\n\t\t\toldtypekey = oldtype;\n\t\t}\n\t\tindex[key][valuekey] = (index[key][valuekey] ? index[key][valuekey] : {});\n\t\tindex[key][valuekey][typekey] = (index[key][valuekey][typekey] ? index[key][valuekey][typekey] : {});\n\t\tindex[key][valuekey][typekey][instance.__rrid__] = instance;\n\t\tif(index[key][oldvaluekey] && index[key][oldvaluekey][oldtypekey]) {\n\t\t\tdelete index[key][oldvaluekey][oldtypekey][instance.__rrid__];\n\t\t}\n\t}\n\tfunction matchObject(index,instance,parentkeys,parentinstances) {\n\t\tif(!index) { return false; }\n\t\tvar\tkeys, primitive = false, instances;\n\t\tif(instance instanceof Number || instance instanceof String || instance instanceof Boolean || [\"number\",\"string\",\"boolean\"].indexOf(typeof(instance))>=0) {\n\t\t\tkeys = [\"value\"];\n\t\t\tprimitive = true;\n\t\t} else {\n\t\t\tkeys = Object.keys(instance);\n\t\t}\t\n\t\tparentkeys = (parentkeys ? parentkeys : []);\n\t\tparentinstances = (parentinstances ? parentinstances : []);\n\t\treturn keys.every(function(key) {\n\t\t\tif(!primitive && !index[key]) { return false; }\n\t\t\tvar value = (primitive ? instance.valueOf() : instance[key]), type = typeof(value), valuekey, typekey;\n\t\t\tif(type===\"object\" && value) {\n\t\t\t\tif(parentkeys.indexOf(key)>=0 && parentkeys.indexOf(key)===parentinstances.indexOf(value)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar valuekeys = Object.keys(index[key]);\n\t\t\t\treturn valuekeys.some(function(valuekey) {\n\t\t\t\t\tvar parts = valuekey.split(\"@\");\n\t\t\t\t\tif(parts.length!==2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar cons = Function(\"return \" + parts[0])();\n\t\t\t\t\tif(typeof(cons)!==\"function\" || !cons.index) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tparentkeys.push(key);\n\t\t\t\t\tparentinstances.push(value);\n\t\t\t\t\treturn matchObject(cons.index,value,parentkeys,parentinstances);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvaluekey = value;\n\t\t\t}\n\t\t\tif(value===null || typeof(value)===\"undefined\") {\n\t\t\t\ttypekey = \"undefined\";\n\t\t\t} else {\n\t\t\t\ttypekey = type;\n\t\t\t}\n\t\t\tif(!index[key][valuekey]) { return false; }\n\t\t\tif(!index[key][valuekey][typekey]) { return false; }\n\t\t\tif(instance.__rrid__ && !index[key][valuekey][typekey][instance.__rrid__]){  return false; }\n\t\t\tinstances = (instances ? intersection(instances,Object.keys(index[key][valuekey][typekey]))  : Object.keys(index[key][valuekey][typekey]));\n\t\t\treturn instances.length>0;\n\t\t});\n\t}\n\tfunction notMatchObject(index,instance,parentkeys,parentinstances) {\n\t\tif(!index) { return false; }\n\t\tvar\tprimitive = false;\n\t\tif(instance instanceof Number || instance instanceof String || instance instanceof Boolean || [\"number\",\"string\",\"boolean\"].indexOf(typeof(instance))>=0) {\n\t\t\tprimitive = true;\n\t\t}\t\n\t\tparentkeys = (parentkeys ? parentkeys : []);\n\t\tparentinstances = (parentinstances ? parentinstances : []);\n\t\treturn Object.keys(index).some(function(key) {\n\t\t\tvar value = (primitive ? instance.valueOf() : instance[key]), type = typeof(value);\n\t\t\tif(!primitive && typeof(instance[key])===\"undefined\") {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(type===\"object\" && value) {\n\t\t\t\tif(parentkeys.indexOf(key)>=0 && parentkeys.indexOf(key)===parentinstances.indexOf(value)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar valuekeys = Object.keys(index[key]);\n\t\t\t\treturn valuekeys.some(function(valuekey) {\n\t\t\t\t\tvar parts = valuekey.split(\"@\");\n\t\t\t\t\tif(parts.length!==2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar cons = Function(\"return \" + parts[0])();\n\t\t\t\t\tif(typeof(cons)!==\"function\" || !cons.index) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tparentkeys.push(key);\n\t\t\t\t\tparentinstances.push(value);\n\t\t\t\t\treturn notMatchObject(cons.index,value,parentkeys,parentinstances);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn Object.keys(index[key]).some(function(valuekey) {\n\t\t\t\tif(valuekey!==value+\"\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Object.keys(index[key][valuekey]).some(function(typekey) {\n\t\t\t\t\tif(typekey!==type) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\tfunction RuleReactor (domain,boost) {\n\t\tthis.boost = boost;\n\t\tthis.rules = {};\n\t\tthis.triggerlessRules = {};\n\t\tthis.data = new Map();\n\t\tthis.agenda = [];\n\t\tthis.run.assertions = 0;\n\t\tthis.run.modifications = 0;\n\t\tthis.run.executions = 0;\n\t\tthis.domain = (domain ? domain : {});\n\t}\n\tRuleReactor.prototype.assert = function(instances,callback) {\n\t\tvar me = this;\n\t\t// add instance to class.constructor.instances\n\t\tinstances = (Array.isArray(instances) || instances instanceof Array ? instances : [instances]);\n\t\tvar instancestoprocess = [];\n\t\tinstances.forEach(function(instance) {\n\t\t\t// don't bother processing instances that don't impact rules or are already in the data store\n\t\t\tif(instance && typeof(instance)===\"object\") { // !RuleReactor.data.has(instance)\n\t\t\t\tif(typeof(instance.__rrid__)===\"undefined\") {\n\t\t\t\t\tObject.defineProperty(instance,\"__rrid__\",{value:uuid.v4()});\n\t\t\t\t}\n\t\t\t\tif(me.data.has(instance.__rrid)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(me.tracelevel>2) {\n\t\t\t\t\tConsole.log(\"Assert: \",instance);\n\t\t\t\t}\n\t\t\t\tme.run.assertions++;\n\t\t\t\tme.data.set(instance.__rrid__,instance);\n\t\t\t\tme.dataModified = true;\n\t\t\t\tinstancestoprocess.push(instance);\n\t\t\t\t// fixes issue #21\n\t\t\t\tif ( !instance.constructor.hasOwnProperty('instances') ) instance.constructor.instances = [];\n\t\t\t\tif ( !instance.constructor.hasOwnProperty('index') ) instance.constructor.index = {};\n\t\t\t\t///instance.constructor.instances = (instance.constructor.instances ? instance.constructor.instances : []);\n\t\t\t\tinstance.constructor.instances.push(instance);\n\t\t\t\t//instance.constructor.index = (instance.constructor.index ? instance.constructor.index : {});\n\t\t\t\tindexObject(instance.constructor.index,instance);\n\t\t\t\t// patch any keys on instance or those identified as active while compiling\n\t\t\t\tvar keys = Object.keys(instance);\n\t\t\t\tif(instance.activeKeys) {\n\t\t\t\t\tObject.keys(instance.activeKeys).forEach(function(key) {\n\t\t\t\t\t\tif(keys.indexOf(key)===-1) {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tkeys.forEach(function(key) {\n\t\t\t\t\tfunction rrget() {\n\t\t\t\t\t\treturn rrget.value;\n\t\t\t\t\t}\n\t\t\t\t\tfunction rrset(value) {\n\t\t\t\t\t\tif(rrget.value!==value) {\n\t\t\t\t\t\t\tif(me.tracelevel>2) {\n\t\t\t\t\t\t\t\tConsole.log(\"Modify: \",instance,key,rrget.value,\"=>\",value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar oldvalue = rrget.value;\n\t\t\t\t\t\t\t// set new value\n\t\t\t\t\t\t\trrget.value = value;\n\t\t\t\t\t\t\tupdateIndex(instance.constructor.index,instance,key,oldvalue);\n\t\t\t\t\t\t\tme.dataModified = true; // may not have an impact\n\t\t\t\t\t\t\tme.run.modifications++;\n\t\t\t\t\t\t\t// if the value is an object that has possible rule matches, assert it\n\t\t\t\t\t\t\tif(value && value.rules) {\n\t\t\t\t\t\t\t\tme.assert(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// re-test the rules that pattern match the key\n\t\t\t\t\t\t\tif(instance.rules) { \n\t\t\t\t\t\t\t\tObject.keys(instance.rules).forEach(function(rulename) {\n\t\t\t\t\t\t\t\t\tvar rule = instance.rules[rulename];\n\t\t\t\t\t\t\t\t\tif(rule.triggers.some(function(trigger) {\n\t\t\t\t\t\t\t\t\t\treturn Object.keys(trigger.range).some(function(variable) {\n\t\t\t\t\t\t\t\t\t\t\treturn trigger.range[variable][key] && instance instanceof trigger.domain[variable];\n\t\t\t\t\t\t\t\t\t}); })) {\n\t\t\t\t\t\t\t\t\t\tvar activations = rule.activations.get(instance);\n\t\t\t\t\t\t\t\t\t\tif(activations) {\n\t\t\t\t\t\t\t\t\t\t\tactivations.forEach(function(activation) {\n\t\t\t\t\t\t\t\t\t\t\t\tactivation.cancel();\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\trule.test(instance,key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn rrget.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(instance,key);\n\t\t\t\t\tvar originalDescriptor;\n\t\t\t\t\tif(desc) {\n\t\t\t\t\t\toriginalDescriptor = {};\n\t\t\t\t\t\tObject.keys(desc).forEach(function(key) {\n\t\t\t\t\t\t\toriginalDescriptor[key] = desc[key];\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// create a new descriptor if one does not exist\n\t\t\t\t\tdesc = (desc ? desc : {enumerable:true,configurable:false});\n\t\t\t\t\tif(!desc.get || desc.get.name!==\"rrget\") {\n\t\t\t\t\t\t// rrget existing value\n\t\t\t\t\t\trrget.value = desc.value;\n\t\t\t\t\t\trrget.originalDescriptor = originalDescriptor;\n\t\t\t\t\t\t// modify arrays\n\t\t\t\t\t\tif(desc.value instanceof Array || Array.isArray(desc.value)) {\n\t\t\t\t\t\t\tvar value = desc.value;\n\t\t\t\t\t\t\toriginalDescriptor.value = value.slice();\n\t\t\t\t\t\t\tvar modifiers = [\"push\",\"pop\",\"splice\",\"shift\",\"unshift\"];\n\t\t\t\t\t\t\tmodifiers.forEach(function(fname) {\n\t\t\t\t\t\t\t\tvar f = value[fname];\n\t\t\t\t\t\t\t\tif(typeof(f)===\"function\") {\n\t\t\t\t\t\t\t\t\tvar newf = function() {\n\t\t\t\t\t\t\t\t\t\tf.apply(value,arguments);\n\t\t\t\t\t\t\t\t\t\tme.run.modifications++;\n\t\t\t\t\t\t\t\t\t\t// re-test the rules that pattern match the key\n\t\t\t\t\t\t\t\t\t\tObject.keys(instance.rules).forEach(function(rulename) {\n\t\t\t\t\t\t\t\t\t\t\tvar rule = instance.rules[rulename];\n\t\t\t\t\t\t\t\t\t\t\tif(rule.triggers.some(function(trigger) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn Object.keys(trigger.range).some(function(variable) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn trigger.range[variable][key] && instance instanceof trigger.domain[variable];\n\t\t\t\t\t\t\t\t\t\t\t});})) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar activations = rule.activations.get(instance);\n\t\t\t\t\t\t\t\t\t\t\t\tif(activations) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tactivations.forEach(function(activation) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tactivation.cancel();\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\trule.test(instance,key);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tObject.defineProperty(rrget.value,fname,{configurable:true,writable:true,value:newf});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tObject.getOwnPropertyNames(Array.prototype).forEach(function(fname) {\n\t\t\t\t\t\t\t\tvar f = value[fname];\n\t\t\t\t\t\t\t\tif(typeof(f)===\"function\" && modifiers.indexOf(fname)===-1) {\n\t\t\t\t\t\t\t\t\tObject.defineProperty(rrget.value,fname,{configurable:true,writable:true,value:function() {\n\t\t\t\t\t\t\t\t\t\treturn f.apply(value,arguments);\n\t\t\t\t\t\t\t\t\t}});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// delete descriptor properties that are inconsistent with rrget/rrset\n\t\t\t\t\t\tdelete desc.value;\n\t\t\t\t\t\tdelete desc.writable;\n\t\t\t\t\t\tdesc.get = rrget;\n\t\t\t\t\t\tdesc.set = rrset;\n\t\t\t\t\t\tObject.defineProperty(instance,key,desc);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tinstancestoprocess.forEach(function(instance) {\n\t\t\tif(instance.rules) {\n\t\t\t\tObject.keys(instance.rules).forEach(function(ruleinstance) {\n\t\t\t\t\tinstance.rules[ruleinstance].bind(instance);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t// test all associated rules\n\t\tinstancestoprocess.forEach(function(instance) {\n\t\t\tif(instance.rules) {\n\t\t\t\tObject.keys(instance.rules).forEach(function(rulename) {\n\t\t\t\t\tvar rule = instance.rules[rulename];\n\t\t\t\t\trule.test(instance);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tif(callback) {\n\t\t\tcallback(null);\n\t\t}\n\t}\n\tRuleReactor.prototype.createRule = function(name,salience,domain,condition,action) {\n\t\tvar me = this, rule = new Rule(this,name,salience,domain,condition,action,me.boost);\n\t\tme.rules[rule.name] = rule;\n\t\tif(rule.triggers.length===0) {\n\t\t\tme.triggerlessRules[rule.name] = rule;\n\t\t}\n\t\treturn rule;\n\t}\n\tRuleReactor.prototype.declare = function(domain,constructor) {\n\t\tif(typeof(module)===\"object\") {\n\t\t\tdomains[domain] = constructor;\n\t\t}\n\t}\n\tRuleReactor.forAll = function forAll(domain,test) {\n\t\tif(typeof(domain)!==\"object\") {\n\t\t\tthrow new TypeError(\"Domain \" + domain + \" is not an object in universal quantification\");\n\t\t}\n\t\tvar variables = Object.keys(domain);\n\t\tif(typeof(test)===\"object\") {\n\t\t\tif(!test) {\n\t\t\t\tthrow new TypeError(\"Universal quantification condition is null\");\n\t\t\t}\n\t\t\treturn Object.keys(test).every(function(variable) {\n\t\t\t\tvar i = variables.indexOf(variable);\n\t\t\t\tif(i===-1) {\n\t\t\t\t\tthrow new ReferenceError(\"Undeclared domain variable '\" + variable + \"' in existential quantification match condition\");\n\t\t\t\t}\n\t\t\t\treturn !notMatchObject(domain[variable].index,test[variable]);\n\t\t\t});\n\t\t}\n\t\tif((test+\"\").indexOf(\"return \")===-1) {\n\t\t\tthrow new TypeError(\"Universal quantification condition function missing a return statement: \" + test);\n\t\t}\n\t\tif(!test.cxproduct) {\n\t\t\tvar collections = [], args;\n\t\t\tvariables.forEach(function(variable) {\n\t\t\t\t// fixes issue #21\n\t\t\t\tif ( !domain[variable].hasOwnProperty('instances') ) domain[variable].instances = [];\n\t\t\t\tif ( !domain[variable].hasOwnProperty('index') ) domain[variable].index = {};\n\t\t\t\t//domain[variable].instances = (domain[variable].instances ? domain[variable].instances: []);\n\t\t\t\tcollections.push(domain[variable].instances);\n\t\t\t});\n\t\t\ttest.cxproduct = new CXProduct(collections);\n\t\t\targs = getFunctionArgs(test);\n\t\t\tif(args.length>0) {\n\t\t\t\ttest.required = args.map(function(variable) { \n\t\t\t\t\tvar i = variables.indexOf(variable);\n\t\t\t\t\tif(i===-1) {\n\t\t\t\t\t\tthrow new ReferenceError(\"Undeclared domain variable '\" + variable + \"' in universal quantification condition function\");\n\t\t\t\t\t}\n\t\t\t\t\treturn i; \n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn test.cxproduct.every(function(row) {\n\t\t\tvar args = [];\n\t\t\tif(!test.required || test.required.every(function(index) { args.push(row[index]); return typeof(row[index])!==\"undefined\"; })) {\n\t\t\t\treturn test.apply(null,args);\n\t\t\t}\n\t\t});\n\t}\n\tRuleReactor.prototype.forAll  = RuleReactor.forAll;\n\tRuleReactor.exists = function exists(domain,test) {\n\t\tif(typeof(domain)!==\"object\") {\n\t\t\tthrow new TypeError(\"Domain \" + domain + \" is not an object in existential quantification\");\n\t\t}\n\t\tvar variables = Object.keys(domain);\n\t\tif(typeof(test)===\"object\") {\n\t\t\tif(!test) {\n\t\t\t\tthrow new TypeError(\"Existential quantification condition is null\");\n\t\t\t}\n\t\t\treturn Object.keys(test).every(function(variable) {\n\t\t\t\tvar i = variables.indexOf(variable);\n\t\t\t\tif(i===-1) {\n\t\t\t\t\tthrow new ReferenceError(\"Undeclared domain variable '\" + variable + \"' in existential quantification match condition\");\n\t\t\t\t}\n\t\t\t\treturn matchObject(domain[variable].index,test[variable]);\n\t\t\t});\n\t\t}\n\t\tif((test+\"\").indexOf(\"return \")===-1) {\n\t\t\tthrow new TypeError(\"Existential quantification condition function missing a return statement: \" + test);\n\t\t}\n\t\tif(!test.cxproduct) {\n\t\t\tvar collections = [], args;\n\t\t\tvariables.forEach(function(variable) {\n\t\t\t\t// fixes issue #21\n\t\t\t\tif ( !domain[variable].hasOwnProperty('instances') ) domain[variable].instances = [];\n\t\t\t\tif ( !domain[variable].hasOwnProperty('index') ) domain[variable].index = {};\n\t\t\t\t//domain[variable].instances = (domain[variable].instances ? domain[variable].instances: []);\n\t\t\t\tcollections.push(domain[variable].instances);\n\t\t\t});\n\t\t\ttest.cxproduct = new CXProduct(collections);\n\t\t\targs = getFunctionArgs(test);\n\t\t\tif(args.length>0) {\n\t\t\t\ttest.required = args.map(function(variable) { \n\t\t\t\t\tvar i = variables.indexOf(variable);\n\t\t\t\t\tif(i===-1) {\n\t\t\t\t\t\tthrow new ReferenceError(\"Undeclared domain variable '\" + variable + \"' in existential quantification condition function\");\n\t\t\t\t\t}\n\t\t\t\t\treturn i; \n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn test.cxproduct.some(function(row) {\n\t\t\tvar args = [];\n\t\t\tif(!test.required || test.required.every(function(index) { args.push(row[index]); return typeof(row[index])!==\"undefined\"; })) {\n\t\t\t\treturn test.apply(null,args);\n\t\t\t}\n\t\t});\n\t}\n\tRuleReactor.prototype.exists = RuleReactor.exists;\n\tRuleReactor.not = function not(value) {\n\t\treturn !value;\n\t}\n\tRuleReactor.prototype.not = RuleReactor.not;\n\tRuleReactor.prototype.retract = function(instances,run) {\n\t\tvar me = this;\n\t\tinstances = (Array.isArray(instances) || instances instanceof Array ? instances : [instances]);\n\t\tinstances.forEach(function(instance) {\n\t\t\tif(instance && typeof(instance)===\"object\") {\n\t\t\t\tif(me.tracelevel>2) {\n\t\t\t\t\tConsole.log(\"Retract: \",instance);\n\t\t\t\t}\n\t\t\t\t// retract from data\n\t\t\t\tme.data.delete(instance.__rrid__);\n\t\t\t\tme.dataModified = true;\n\t\t\t\t// restore instance properties\n\t\t\t\tObject.keys(instance).forEach(function(key) {\n\t\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(instance,key);\n\t\t\t\t\tif(desc.get && desc.get.name===\"rrget\") {\n\t\t\t\t\t\tif(typeof(desc.get.originalDescriptor)===\"undefined\") {\n\t\t\t\t\t\t\tdelete instance[key];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(desc.get.originalDescriptor.value instanceof Array || Array.isArray(desc.get.originalDescriptor.value)) {\n\t\t\t\t\t\t\t\tif(instance[key] instanceof Array || Array.isArray(instance[key])) {\n\t\t\t\t\t\t\t\t\tvar args = [0,instance[key]].concat(desc.get.originalDescriptor.value);\n\t\t\t\t\t\t\t\t\tinstance[key].splice.apply(instance[key],args);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinstance[key] = desc.get.originalDescriptor.value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tObject.defineProperty(instance,key,desc.get.originalDescriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// unbind from all associated rules\n\t\t\t\tObject.keys(instance.rules).forEach(function(rulename) {\n\t\t\t\t\tinstance.rules[rulename].unbind(instance);\n\t\t\t\t});\n\n\t\t\t}\n\t\t});\n\t\tif(run) {\n\t\t\tsetTimeout(function() { me.run(); });\n\t\t}\n\t}\n\tRuleReactor.prototype.reset = function(facts) {\n\t\tvar me = this;\n\t\tObject.keys(me.rules).forEach(function(rulename) {\n\t\t\tme.rules[rulename].reset();\n\t\t});\n\t\tif(facts) {\n\t\t\tvar data = [];\n\t\t\tme.data.forEach(function(instance) {\n\t\t\t\tdata.push(instance);\n\t\t\t});\n\t\t\tme.retract(data,false);\n\t\t}\n\t\tme.run.running = false;\n\t}\n\tRuleReactor.prototype.run = function(max,loose,callback) {\n\t\tvar me = this;\n\t\tfunction run() {\n\t\t\tif(me.run.stop) {\n\t\t\t\tif(me.tracelevel>0) {\n\t\t\t\t\tConsole.log(\"Data Count: \",me.data.size);\n\t\t\t\t\tConsole.log(\"Executions: \",me.run.executions);\n\t\t\t\t\tConsole.log(\"RPS: \",me.run.rps);\n\t\t\t\t}\n\t\t\t\tif(me.tracelevel>1) {\n\t\t\t\t\tObject.keys(me.rules).forEach(function(rulename) {\n\t\t\t\t\t\tvar rule = me.rules[rulename];\n\t\t\t\t\t\tConsole.log(rule.name,rule.potentialMatches,rule.tested,rule.activated,rule.fired);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif(typeof(callback)===\"function\") {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(me.run.executions<me.run.max) {\n\t\t\t\tObject.keys(me.triggerlessRules).forEach(function(rulename) {\n\t\t\t\t\tvar rule = me.triggerlessRules[rulename], activations = rule.activations.get(); // get's activations associated with undefined domains\n\t\t\t\t\tif(!activations || activations.length===0) {\n\t\t\t\t\t\trule.test();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\twhile (me.agenda.length>0) {\n\t\t\t\t\tme.dataModified = false;\n\t\t\t\t\tme.agenda[me.agenda.length-1].execute(me.agenda.length-1);\n\t\t\t\t\tif(me.dataModified) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetTimeout(run,0);\n\t\t}\n\t\tif(me.run.running) { return true; }\n\t\tme.run.max = (max ? max : Infinity);\n\t\tme.run.running = true;\n\t\tme.run.executions = 0;\n\t\tme.run.assertions = 0;\n\t\tme.run.modifications = 0;\n\t\tme.run.start = new Date();\n\t\tme.run.stop = null;\n\t\tif(me.tracelevel>0) {\n\t\t\tConsole.log(\"Run: \",max);\n\t\t}\n\t\tsetTimeout(run,0);\n\t}\n\tRuleReactor.prototype.stop = function() {\n\t\tthis.run.stop = new Date();\n\t\tthis.run.rps = (this.run.executions / (this.run.stop.getTime() - this.run.start.getTime())) * 1000;\n\t\tthis.run.running = false;\n\t}\n\tRuleReactor.prototype.trace = function(level) {\n\t\tthis.tracelevel = level;\n\t\tif(this.processor) {\n\t\t\tif(level>3) {\n\t\t\t\tthis.processor.trace(1);\n\t\t\t} else {\n\t\t\t\tthis.processor.trace(0);\n\t\t\t}\n\t\t}\t\n\t}\n\n\tif (this.exports) {\n\t\tthis.exports  = RuleReactor;\n\t} else if (typeof define === \"function\" && define.amd) {\n\t\t// Publish as AMD module\n\t\tdefine(function() {return RuleReactor;});\n\t} else {\n\t\tthis.RuleReactor = RuleReactor;\n\t}\n}).call((typeof(window)!==\"undefined\" ? window : (typeof(module)!==\"undefined\" ? module : null)));\n\n","/home/travis/build/npmtest/node-npmtest-rule-reactor/node_modules/rule-reactor/browser/rule-reactor.js":"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\n/* MIT License\n\nrule-reactor: A light weight, fast, expressive forward chaining business rule engine leveraging JavaScript internals and Functions as objects rather than Rete.\n\nCopyright (c) 2016 Simon Y. Blackwell\n\n*/\n\nvar uuid = require(\"uuid\");\n//var hamsters = require(\"webhamsters/src/hamsters\");\n//var Parallel = require(\"paralleljs\");\n\n(function() {\n\t\"use strict\";\n\t\n\tvar domains = global;\n\t\n\tfunction intersector(objects) {\n\t\treturn function intersection() {\n\t\t\tvar min = Infinity, // length of shortest array argument\n\t\t\t\tshrtst = 0, // index of shortest array argument\n\t\t\t\tset = (objects ? new Set() : {}),\n\t\t\t\trslt = [], // result\n\t\t\t\tmxj = arguments.length-1;\n\t\t\tfor(var j=0;j<=mxj;j++) { // find index of shortest array argument\n\t\t\t\tvar l = arguments[j].length;\n\t\t\t\tif(l<min) {\n\t\t\t\t\tshrtst = j;\n\t\t\t\t\tmin = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar shrt = arguments[shrtst],\n\t\t\t\tmxi = shrt.length;\n\t\t\tfor(var i=0;i<mxi;i++) { // initialize set of possible values from shortest array\n\t\t\t\tif(objects) { set.add(shrt[i]); } else { set[shrt[i]]=1; }\n\t\t\t}\n\t\t\tfor(var j=0;j<=mxj;j++) { // loop through all array arguments\n\t\t\t\tvar\tarray = arguments[j],\n\t\t\t\t\tmxk = array.length;\n\t\t\t\tfor(var k=0;k<mxk;k++) { // loop through all values\n\t\t\t\t\tvar item = array[k];\n\t\t\t\t\tif((objects && set.has(item)) || set[item]) { // if value is possible\n\t\t\t\t\t\tif(j===mxj) { // and all arrays have it (or we would not be at this point)\n\t\t\t\t\t\t\trslt.push(item); // add to results\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rslt;\n\t\t};\n\t}\n\tvar intersection = intersector(false);\n\t\n//\t\tportions from http://phrogz.net/lazy-cartesian-product\n\tfunction CXProduct(collections){\n\t\tvar me = this;\n\t\tme.collections = (collections ? collections : []);\n\t}\n\tCXProduct.prototype.length = function() {\n\t\tvar me = this;\n\t\tif(me.collections.length===0) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar size = 1;\n\t\tthis.collections.forEach(function(collection) { size *= collection.length; });\n\t\tif(typeof(me.start)===\"number\") {\n\t\t\tif(typeof(me.end)===\"number\") {\n\t\t\t\treturn me.end - me.start;\n\t\t\t}\n\t\t\treturn size - me.start;\n\t\t}\n\t\treturn size; \n\t};\n\tCXProduct.prototype.length.size = CXProduct.prototype.length;\n\tCXProduct.prototype.every = function(callback,pattern) {\n\t\tfunction dive(cxproduct,d,counter,collections,lens,p,callback,pattern){\n\t\t\tvar a=collections[d], max=collections.length-1,len=lens[d];\n\t\t\tif (d===max) {\n\t\t\t\tfor (var i=0;i<len;++i) { \n\t\t\t\t\tp[d]=a[i]; \n\t\t\t\t\tif(!callback(p.slice(0),counter.count)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tcounter.count++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var j=0;j<len;++j) {\n\t\t\t\t\tp[d]=a[j];\n\t\t\t\t\tdive(cxproduct,d+1,counter,collections,lens,p,callback,pattern);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.pop();\n\t\t}\n\t\tif(typeof(start)===\"number\") {\n\t\t\treturn this.some2(callback,pattern);\n\t\t}\n\t\tvar me = this, p=[],lens=[];\n\t\tfor (var i=me.collections.length;i--;) { lens[i]=me.collections[i].length; }\n\t\tif(dive(me,0,{count:0},me.collections,lens,p,callback,pattern)!==false) {\n\t\t\treturn true;\n\t\t}\n\t};\n\tCXProduct.prototype.get = function(index,pattern){\n\t\tfunction get(n,collections,dm,c) {\n\t\t\tfor (var i=collections.length;i--;) { c[i]=collections[i][(n/dm[i][0]<<0)%dm[i][1]]; }\n\t\t}\n\t\tvar me = this, dm = [], c = [];\n\t\tfor (var f=1,l,i=me.collections.length;i--;f*=l) { dm[i]=[f,l=me.collections[i].length];  }\n\t\tif(index>=me.length()) {\n\t\t\treturn; // undefined\n\t\t}\n\t\tget(index,me.collections,dm,c);\n\t\tif(!pattern || pattern.every(function(value,i) {\n\t\t\treturn typeof(value)===\"undefined\" || (typeof(value)===\"function\" ? value.call(c,c[i],i) : false) || c[i]===value;\n\t\t})) {\n\t\t\treturn c.slice(0);\n\t\t}\n\t}\n\tCXProduct.prototype.some = function(callback,pattern) {\n\t\tfunction dive(cxproduct,d,counter,collections,lens,p,callback,pattern){\n\t\t\tvar a=collections[d], max=collections.length-1,len=lens[d];\n\t\t\tif (d===max) {\n\t\t\t\tfor (var i=0;i<len;++i) { \n\t\t\t\t\tp[d]=a[i]; \n\t\t\t\t\tif(callback(p.slice(0),counter.count)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcounter.count++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var j=0;j<len;++j) {\n\t\t\t\t\tp[d]=a[j];\n\t\t\t\t\tdive(cxproduct,d+1,counter,collections,lens,p,callback,pattern);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.pop();\n\t\t}\n\t\tif(typeof(start)===\"number\") {\n\t\t\treturn this.some2(callback,pattern);\n\t\t}\n\t\tvar me = this, p=[],lens=[];\n\t\tfor (var i=me.collections.length;i--;) { lens[i]=me.collections[i].length; }\n\t\treturn dive(me,0,{count:0},me.collections,lens,p,callback,pattern);\n\t}\n\tCXProduct.prototype.some2 = function(callback,pattern) {\n\t\tvar me = this, i = 0, value, max = me.length();\n\t\tdo {\n\t\t\tvalue = me.get(i);\n\t\t\tif(typeof(value)!==\"undefined\" && (!callback || callback(value)) && (!pattern || me.testpattern(pattern,value))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ti++;\n\t\t} while(i<max); \n\t\treturn false;\n\t}\n\tCXProduct.prototype.verify = function(i,row) {\n\t\tvar me = this;\n\t\tvar match = me.get(i);\n\t\treturn match && match.every(function(element,i) { return element===row[i]; });\n\t}\n\tCXProduct.prototype.forEach1 = function(callback) {\n\t\tfunction dive(cxproduct,d,counter,collections,lens,p,callback){\n\t\t\tvar a=collections[d], max=collections.length-1,len=lens[d];\n\t\t\tif (d===max) {\n\t\t\t\tfor (var i=0;i<len;++i) { \n\t\t\t\t\tp[d]=a[i]; \n\t\t\t\t\tcallback(p.slice(0),counter.count); \n\t\t\t\t\tcounter.count++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var j=0;j<len;++j) {\n\t\t\t\t\tp[d]=a[j];\n\t\t\t\t\tdive(cxproduct,d+1,counter,collections,lens,p,callback);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.pop();\n\t\t}\n\t\tif(typeof(start)===\"number\") {\n\t\t\tthis.forEach2(callback);\n\t\t\treturn;\n\t\t}\n\t\tvar me = this, p=[],lens=[];\n\t\tfor (var i=me.collections.length;i--;) { lens[i]=me.collections[i].length; }\n\t\tdive(me,0,{count:0},me.collections,lens,p,callback);\n\t}\n\tCXProduct.prototype.forEach2 = function(callback) {\n\t\tvar me = this, i = (typeof(me.start)===\"number\" ? me.start : 0), max = (typeof(me.end)===\"number\" ? me.end : me.length());\n\t\twhile(i<max) {\n\t\t\tvar value = me.get(i);\n\t\t\tif(typeof(value)!==\"undefined\") {\n\t\t\t\tcallback(value);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tCXProduct.prototype.forEach = CXProduct.prototype.forEach1;//\tportions from http://phrogz.net/lazy-cartesian-product\n\t\n\t\n\tfunction getFunctionArgs(f) {\n\t\tvar str = f+\"\";\n\t\tvar start = str.indexOf(\"(\")+1;\n\t\tvar end = str.indexOf(\")\");\n\t\tvar result = str.substring(start,end).split(\",\");\n\t\tresult.forEach(function(arg,i) {\n\t\t\tresult[i] = arg.trim();\n\t\t});\n\t\tif(result.length===1 && result[0]===\"\") {\n\t\t\treturn [];\n\t\t}\n\t\treturn result;\n\t}\n\tfunction compile(reactor,rule,boost) {\n\t\tvar variables = Object.keys(rule.domain);\n\t\tvariables.forEach(function(variable) {\n\t\t\tvar cons = rule.domain[variable];\n\t\t\tif(typeof(cons)!==\"function\") {\n\t\t\t\tthrow new TypeError(\"Domain variable \" + variable + \" is not a constructor in rule \" + rule.name);\n\t\t\t}\n\t\t\tif(!cons.name || cons.name.length===0 || cons.name===\"anonymous\") {\n\t\t\t\tthrow new TypeError(\"Constructor for domain variable \" + variable + \" in rule \" + rule.name + \" must have a name.\");\n\t\t\t}\n\t\t\tif(!rule.reactor.domain[cons.name]) {\n\t\t\t\trule.reactor.domain[cons.name] = cons;\n\t\t\t}\n\t\t\t//cons.instances = (cons.instances ? cons.instances : []);\n\t\t\t//cons.index = (cons.index ? cons.index : {});\n\t\t\t// below fixes issue #21, thanks @zelgadis87\n\t\t\tif ( !cons.hasOwnProperty('instances') ) cons.instances = [];\n\t\t\tif ( !cons.hasOwnProperty('index') ) cons.index = {};\n\t\t\tcons.prototype.rules = (cons.prototype.rules ? cons.prototype.rules : {});\n\t\t\tcons.prototype.rules[rule.name] = rule;\n\t\t\tcons.prototype.activeKeys = (cons.prototype.activeKeys ? cons.prototype.activeKeys : {});\n\t\t\tcons.exists = function(f) {\n\t\t\t\tf = (f ? f : function() { return true; });\n\t\t\t\treturn cons.instances && cons.instances.some(function(instance) {\n\t\t\t\t\treturn f(instance);\n\t\t\t\t});\n\t\t\t};\n\t\t\tcons.forAll = function(f) {\n\t\t\t\treturn cons.instances && cons.instances.every(function(instance) {\n\t\t\t\t\treturn f(instance);\n\t\t\t\t});\n\t\t\t};\n\t\t\trule.range[variable] = {};\n\t\t\trule.bindings[variable] = (rule.bindings[variable] ? rule.bindings[variable] : []);\n\t\t\t// extract instance keys from condition using a side-effect of replace\n\t\t\trule.conditions.forEach(function(condition) {\n\t\t\t\t(condition+\"\").replace(new RegExp(\"(\\\\b\"+variable+\"\\\\.\\\\w+\\\\b)\",\"g\"),\n\t\t\t\t\tfunction(match) { \n\t\t\t\t\t\tvar parts = match.split(\".\"),key = parts[1];\n\t\t\t\t\t\t// cache reactive non-function keys on class prototype\n\t\t\t\t\t\tif(key.indexOf(\"(\")===-1) {\n\t\t\t\t\t\t\tcons.prototype.activeKeys[key] = true;\n\t\t\t\t\t\t\t// cache what keys are associated with what variables\n\t\t\t\t\t\t\trule.range[variable][key] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// don't really do a replace!\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t\tif(variables.length>0) {\n\t\t\trule.triggers.push({domain:rule.domain,range:rule.range});\n\t\t}\n\t\trule.conditions.forEach(function(condition) {\n\t\t\t(condition+\"\").replace(/exists\\(\\s*(\\s*{.*\\s*})\\s*,\\s*(.*)\\s*\\)/g,\n\t\t\t\tfunction(match,domainstr,conditionstr) {\n\t\t\t\t\tvar domain = new Function(\"return \" + domainstr)(),\n\t\t\t\t\t\tvariables = Object.keys(domain),\n\t\t\t\t\t\tquantification = {domain: domain, range: {}};\n\t\t\t\t\trule.triggers.push(quantification);\n\t\t\t\t\tvariables.forEach(function(variable) {\n\t\t\t\t\t\tvar cons = domain[variable];\n\t\t\t\t\t\tif(!rule.reactor.domain[cons.name]) {\n\t\t\t\t\t\t\trule.reactor.domain[cons.name] = cons;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tquantification.range[variable] = (quantification.range[variable] ? quantification.range[variable] : {});\n\t\t\t\t\t\tcons.prototype.rules = (cons.prototype.rules ? cons.prototype.rules : {});\n\t\t\t\t\t\tcons.prototype.rules[rule.name] = rule;\n\t\t\t\t\t\tcons.prototype.activeKeys = (cons.prototype.activeKeys ? cons.prototype.activeKeys : {});\n\t\t\t\t\t\tconditionstr.replace(new RegExp(\"(\\\\b\"+variable+\"\\\\.\\\\w+\\\\b)\",\"g\"),\n\t\t\t\t\t\t\tfunction(match) { \n\t\t\t\t\t\t\t\tvar parts = match.split(\".\"),key = parts[1];\n\t\t\t\t\t\t\t\t// cache reactive non-function keys on class prototype\n\t\t\t\t\t\t\t\tif(key.indexOf(\"(\")===-1) {\n\t\t\t\t\t\t\t\t\tcons.prototype.activeKeys[key] = true;\n\t\t\t\t\t\t\t\t\t// cache what keys are associated with what variables\n\t\t\t\t\t\t\t\t\tquantification.range[variable][key] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// don't really do a replace!\n\t\t\t\t\t\t\t\treturn match;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\t// don't really do a replace!\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t);\n\t\t\t(condition+\"\").replace(/forAll\\(\\s*(\\s*{.*\\s*})\\s*,\\s*(.*)\\s*\\)/g,\n\t\t\t\t\tfunction(match,domainstr,conditionstr) {\n\t\t\t\t\t\tvar domain = new Function(\"return \" + domainstr)(), variables = Object.keys(domain);\n\t\t\t\t\t\tvar quantification = {domain: domain, range: {}};\n\t\t\t\t\t\trule.triggers.push(quantification);\n\t\t\t\t\t\tvariables.forEach(function(variable) {\n\t\t\t\t\t\t\tvar cons = domain[variable];\n\t\t\t\t\t\t\tif(!rule.reactor.domain[cons.name]) {\n\t\t\t\t\t\t\t\trule.reactor.domain[cons.name] = cons;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquantification.range[variable] = (quantification.range[variable] ? quantification.range[variable] : {});\n\t\t\t\t\t\t\tcons.prototype.rules = (cons.prototype.rules ? cons.prototype.rules : {});\n\t\t\t\t\t\t\tcons.prototype.rules[rule.name] = rule;\n\t\t\t\t\t\t\tcons.prototype.activeKeys = (cons.prototype.activeKeys ? cons.prototype.activeKeys : {});\n\t\t\t\t\t\t\tconditionstr.replace(new RegExp(\"(\\\\b\"+variable+\"\\\\.\\\\w+\\\\b)\",\"g\"),\n\t\t\t\t\t\t\t\tfunction(match) { \n\t\t\t\t\t\t\t\t\tvar parts = match.split(\".\"),key = parts[1];\n\t\t\t\t\t\t\t\t\t// cache reactive non-function keys on class prototype\n\t\t\t\t\t\t\t\t\tif(key.indexOf(\"(\")===-1) {\n\t\t\t\t\t\t\t\t\t\tcons.prototype.activeKeys[key] = true;\n\t\t\t\t\t\t\t\t\t\t// cache what keys are associated with what variables\n\t\t\t\t\t\t\t\t\t\tquantification.range[variable][key] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// don't really do a replacereactornt!\n\t\t\t\t\t\t\t\t\treturn match;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// don't really do a replacereactornt!\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t});\n\t\trule.compiledConditions = [];\n\t\trule.conditions.forEach(function(condition,i) {\n\t\t\tif((condition+\"\").indexOf(\"return\")===-1) {\n\t\t\t\tthrow new TypeError(\"Condition function missing a return statereactornt in rule '\" + rule.name + \"' condition \" + i);\n\t\t\t}\n\t\t\tvar args = getFunctionArgs(condition);\n\t\t\tcondition.required = new Array(args.length);\n\t\t\targs.forEach(function(arg,j) {\n\t\t\t\tvar required = variables.indexOf(arg);\n\t\t\t\tif(required===-1) {\n\t\t\t\t\tthrow new ReferenceError(\"Referenced domain variable '\" + arg + \"' undefined in rule '\" + rule.name + \"' condition \",i);\n\t\t\t\t}\n\t\t\t\tcondition.required[j] = required;\n\t\t\t});\n\t\t\tif(!boost) {\n\t\t\t\trule.compiledConditions.push(function(match) {\n\t\t\t\t\tvar reactor = this, args = [];\n\t\t\t\t\t// no required = domainless\n\t\t\t\t\tif(!condition.required || condition.required.every(function(i) {\n\t\t\t\t\t\tif(typeof(match[i])!==\"undefined\") {\n\t\t\t\t\t\t\treturn args.push(match[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t})) {\n\t\t\t\t\t\treturn condition.apply(reactor,args);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar required = (condition.required ? condition.required : []);\n\t\t\t\tvar f = new Function(\"match\",\"var args = [];if(\" + JSON.stringify(required) + \".every(function(i,j,required){if(match[i]!==undefined){return args.push(match[i]);}})) {return (\" + condition + \").apply(undefined,args);}\");\n\t\t\t\trule.compiledConditions.push(f);\n\t\t\t}\n\t\t});\n\t\tvar args = getFunctionArgs(rule.action);\n\t\trule.action.required = new Array(args.length);\n\t\targs.forEach(function(arg,i) {\n\t\t\tvar required = variables.indexOf(arg);\n\t\t\tif(required===-1) {\n\t\t\t\tthrow new ReferenceError(\"Referenced domain variable '\" + arg + \"' undefined in rule '\" + rule.name + \"' action\");\n\t\t\t}\n\t\t\trule.action.required[i] = required;\n\t\t\t\n\t\t});\n\t\t// do not add full compilation since actions are allowed to use closure scope and it will break that\n\t\trule.compiledAction = function(match) {\n\t\t\tvar reactor = this, args = [];\n\t\t\t// no required = domainless\n\t\t\tif(!rule.action.required || rule.action.required.every(function(i) {\n\t\t\t\tif(typeof(match[i])!==\"undefined\") {\n\t\t\t\t\treturn args.push(match[i]);\n\t\t\t\t}\n\t\t\t})) {\n\t\t\t\trule.action.apply(reactor,args);\n\t\t\t}\n\t\t};\n\t}\n\n\t// dummy console so logging can easily be retractd\n\tvar Console = {};\n\tConsole.log = function() { \n\t\tvar c = console;\n\t\tc.log.apply(console,arguments); \n\t};\n\t// uncomment line below to stop logging\n\t//Console.log = function() {};\n\t\n\t// http://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers\n\tfunction insertSorted(arr, item, comparator) {\n\t\tif (comparator == null) {\n\t\t\t// emulate the default Array.sort() comparator\n\t\t\tcomparator = function(a, b) {\n\t\t\t\tif (typeof a !== \"string\") { a = String(a); }\n\t\t\t\tif (typeof b !== \"string\") { b = String(b); }\n\t\t\t\treturn (a > b ? 1 : (a < b ? -1 : 0));\n\t\t\t};\n\t\t}\n\t\t// get the index we need to insert the item at\n\t\tvar min = 0;\n\t\tvar max = arr.length;\n\t\tvar index = Math.floor((min + max) / 2);\n\t\twhile (max > min) {\n\t\t\tif (comparator(item, arr[index]) < 0) {\n\t\t\t\tmax = index;\n\t\t\t} else {\n\t\t\t\tmin = index + 1;\n\t\t\t}\n\t\t\tindex = Math.floor((min + max) / 2);\n\t\t}\n\t\t// insert the item\n\t\tarr.splice(index, 0, item);\n\t}\n\n\tfunction Activation(rule,match,index,bindings,instance) {\n\t\tvar me = this;\n\t\tme.timestamp = new Date();\n\t\tme.rule = rule;\n\t\tme.match = match;\n\t\tme.index = index;\n\t\tme.bindings = bindings;\n\t\tme.instance = instance;\n\t\tme.rule.activated++;\n\t\tinsertSorted(me.rule.reactor.agenda,me,function(a,b) { return (a.rule.salience > b.rule.salience ? 1 : (a.rule.salience < b.rule.salience ? -1 : 0)); });\n\t\tvar activations = rule.activations.get(instance);\n\t\tif(!activations) {\n\t\t\tactivations = [];\n\t\t}\n\t\tactivations.push(me);\n\t\trule.activations.set(instance,activations);\n\t\tif(me.rule.reactor.tracelevel>1) {\n\t\t\tConsole.log(\"Activating: \",rule,match);\n\t\t}\n\t}\n\tActivation.prototype.cancel = function() {\n\t\tthis.cancelled = true;\n\t}\n\tActivation.prototype.execute = function(index) {\n\t\tvar me = this;\n\t\t// re-test just in-case\n\t\tme.delete(undefined,index,true);\n\t\tif(!me.cancelled && (!me.bindings || me.bindings.verify(me.index,me.match)) && me.rule.compiledConditions.every(function(condition) {\n\t\t\treturn condition.call(me,me.match);\n\t\t})) {\n\t\t\tme.rule.fire(me.match);\n\t\t}\n\t}\n\tActivation.prototype.delete = function(instance,index,supresslog) {\n\t\tvar me = this, i;\n\t\tif(!instance || me.match.indexOf(instance)>=0) {\n\t\t\tif(!supresslog && me.rule.reactor.tracelevel>1) {\n\t\t\t\tConsole.log(\"Deactivating: \",me.rule,me.match);\n\t\t\t}\n\t\t\tvar activations = me.rule.activations.get(instance);\n\t\t\tif(activations) {\n\t\t\t\ti = activations.indexOf(me);\n\t\t\t\tif(i>=0) {\n\t\t\t\t\tactivations.splice(i,1);\n\t\t\t\t\tif(activations.length===0) {\n\t\t\t\t\t\tme.rule.activations.delete(instance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(typeof(index)!==\"undefined\") {\n\t\t\t\tif(index===me.rule.reactor.agenda.length-1) {\n\t\t\t\t\tme.rule.reactor.agenda.pop();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tme.rule.reactor.agenda.splice(index,1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ti = me.rule.reactor.agenda.indexOf(me);\n\t\t\tif(i>=0) {\n\t\t\t\tme.rule.reactor.agenda.splice(i,1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction Rule(reactor,name,salience,domain,condition,action,boost) {\n\t\tvar me = this;\n\t\tme.boost = boost;\n\t\tme.name = name;\n\t\tme.reactor = reactor;\n\t\tif(typeof(salience)!==\"number\") {\n\t\t\tthrow new TypeError(\"Salience \" + salience + \" is not a number in rule \" + name);\n\t\t}\n\t\tme.salience = salience;\n\t\tme.domain = domain;\n\t\tif(typeof(domain)!==\"object\") {\n\t\t\tthrow new TypeError(\"Domain \" + domain + \" is not an object in rule \" + name);\n\t\t}\n\t\tme.range = {};\n\t\tme.triggers = [];\n\t\tme.conditions = (Array.isArray(condition) || condition instanceof Array ? condition : [condition]);\n\t\tme.pattern = new Array(Object.keys(domain).length);\n\t\tif(typeof(action)!==\"function\") {\n\t\t\tthrow new TypeError(\"Action \" + action + \" is not a function in rule \" + name);\n\t\t}\n\t\tme.action = action;\n\t\tme.bindings = {};\n\t\tme.activations = new Map();\n\t\tme.potentialMatches = 0;\n\t\tme.tested = 0;\n\t\tme.activated = 0;\n\t\tme.fired = 0;\n\t\tcompile(reactor,me,me.boost);\n\t\tif(me.reactor.tracelevel>2) {\n\t\t\tConsole.log(\"New Rule: \",me);\n\t\t}\n\t\tme.bindInstances(true);\n\t} \n\tRule.prototype.bind = function(instance,test) {\n\t\tvar me = this, variables = Object.keys(me.bindings);\n\t\tvariables.map(function(variable) {\n\t\t\tif(instance instanceof me.domain[variable] && me.bindings[variable].indexOf(instance)===-1) {\n\t\t\t\tif(me.reactor.tracelevel>2) {\n\t\t\t\t\tConsole.log(\"Binding: \",me,variable,instance);\n\t\t\t\t}\n\t\t\t\tme.bindings[variable].push(instance);\n\t\t\t}\n\t\t});\n\t\tif(test) {\n\t\t\treturn me.test(instance);\n\t\t}\n\t}\n\tRule.prototype.bindInstances = function(test) {\n\t\tvar me = this, variables = Object.keys(me.domain);\n\t\tvariables.forEach(function(variable) {\n\t\t\tme.domain[variable].instances.forEach(function(instance) {\n\t\t\t\tme.bind(instance,test);\n\t\t\t});\n\t\t});\n\t}\n\tRule.prototype.delete = function() {\n\t\tvar me = this, variables = Object.keys(me.domain);\n\t\tvariables.forEach(function(variable) {\n\t\t\tvar cons = me.domain[variable];\n\t\t\tdelete cons.prototype.rules[me.name];\n\t\t});\n\t}\n\tRule.prototype.fire = function(match) {\n\t\tvar me = this;\n\t\tif(me.reactor.tracelevel>0) {\n\t\t\tConsole.log(\"Firing: \",this,match);\n\t\t}\n\t\tthis.fired++;\n\t\tthis.reactor.run.executions++;\n\t\tthis.compiledAction(match);\n\t}\n\tRule.prototype.test = function(instance,key) {\n\t\tvar me = this, variables = Object.keys(me.domain), result = false, values = [];\n\t\tif(!variables.every(function(variable) {\n\t\t\tvalues.push(me.bindings[variable]);\n\t\t\treturn me.bindings[variable].length>0;\n\t\t})) {\n\t\t\tme.cxproduct = null;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(!me.cxproduct) {\n\t\t\tme.cxproduct = new CXProduct(values);\n\t\t}\n\t\tif(me.reactor.tracelevel>2) {\n\t\t\tConsole.log(\"Testing: \",me,instance,key);\n\t\t}\n\t\tme.tested++;\n\t\tvar test = function (match,i) {\n\t\t\tif(me.compiledConditions.every(function(condition) {\n\t\t\t\treturn condition.call(me,match);\n\t\t\t})) {\n\t\t\t\tnew Activation(me,match,i,me.cxproduct,instance);\n\t\t\t\tresult = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif(variables.length===0) {\n\t\t\tif(test()) {\n\t\t\t\tresult = true;\n\t\t\t} else {\n\t\t\t\tme.reset(instance);\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t} else {\n\t\t\tme.potentialMatches = Math.max(me.potentialMatches,me.cxproduct.length());\n\t\t\tif(instance) {\n\t\t\t\tvariables.forEach(function(variable,i) {\n\t\t\t\t\tvar collections = me.cxproduct.collections.slice(0);\n\t\t\t\t\tif(instance instanceof me.domain[variable]) {\n\t\t\t\t\t\tcollections[i] = [instance];\n\t\t\t\t\t\tvar cxproduct = new CXProduct(collections);\n\t\t\t\t\t\ttest = function (match,i) {\n\t\t\t\t\t\t\tif(me.compiledConditions.every(function(condition) {\n\t\t\t\t\t\t\t\treturn condition.call(me,match);\n\t\t\t\t\t\t\t})) {\n\t\t\t\t\t\t\t\tnew Activation(me,match,i,cxproduct,instance);\n\t\t\t\t\t\t\t\tresult = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcxproduct.forEach(test);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tme.cxproduct.forEach(test);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tRule.prototype.reset = function(instance) {\n\t\tvar me = this;\n\t\tif(me.reactor.tracelevel>2) {\n\t\t\tConsole.log(\"Reseting: \",me,instance);\n\t\t}\n\t\tme.activations.forEach(function(activations,activator) {\n\t\t\tif(!instance || activator===instance) {\n\t\t\t\tactivations.forEach(function(activation) {\n\t\t\t\t\tvar i = me.reactor.agenda.indexOf(activation);\n\t\t\t\t\tif(i>=0) {\n\t\t\t\t\t\tme.reactor.agenda.splice(i,1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}\n\t\t});\n\t}\n\t\n\tRule.prototype.unbind = function(instance) {\n\t\tvar me = this, variables = Object.keys(me.bindings);\n\t\tvariables.map(function(variable) {\n\t\t\tif(instance instanceof me.domain[variable]) {\n\t\t\t\tvar i = me.bindings[variable].indexOf(instance);\n\t\t\t\tif(i>=0) {\n\t\t\t\t\tif(me.reactor.tracelevel>2) {\n\t\t\t\t\t\tConsole.log(\"Unbinding: \",me,variable,instance);\n\t\t\t\t\t}\n\t\t\t\t\tme.bindings[variable].splice(i,1);\n\t\t\t\t\tif(me.bindings[variable].length===0) {\n\t\t\t\t\t\tme.cxproduct = null;\n\t\t\t\t\t}\n\t\t\t\t\tme.reset(instance);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction indexObject(index,instance) {\n\t\tvar keys, primitive = false;\n\t\tif(instance instanceof Number || instance instanceof String || instance instanceof Boolean) {\n\t\t\tkeys = [\"value\"];\n\t\t\tprimitive = true;\n\t\t} else {\n\t\t\tkeys = Object.keys(instance);\n\t\t}\t\n\t\tkeys.forEach(function(key) {\n\t\t\tindex[key] = (index[key] ? index[key] : {});\n\t\t\tvar value = (primitive ? instance.valueOf() : instance[key]), type = typeof(value), valuekey, typekey;\n\t\t\tif(type===\"object\" && value) {\n\t\t\t\tif(typeof(value.__rrid__)===\"undefined\") {\n\t\t\t\t\tObject.defineProperty(value,\"__rrid__\",{value:uuid.v4()});\n\t\t\t\t}\n\t\t\t\tvaluekey = value.constructor.name + \"@\" + value.__rrid__;\n\t\t\t} else {\n\t\t\t\tvaluekey = value;\n\t\t\t}\n\t\t\tif(value===null || typeof(value)===\"undefined\") {\n\t\t\t\ttypekey = \"undefined\";\n\t\t\t} else {\n\t\t\t\ttypekey = type;\n\t\t\t}\n\t\t\tindex[key][valuekey] = (index[key][valuekey] ? index[key][valuekey] : {});\n\t\t\tindex[key][valuekey][typekey] = (index[key][valuekey][typekey] ? index[key][valuekey][typekey] : {});\n\t\t\tindex[key][valuekey][typekey][instance.__rrid__] = instance;\n\t\t});\n\t}\n\tfunction updateIndex(index,instance,key,oldValue) {\n\t\tif(typeof(instance[key])===\"undefined\" && !index[key]) { return; }\n\t\tindex[key] = (index[key] ? index[key] : {});\n\t\tvar value = instance[key], type = typeof(value), oldtype = typeof(oldValue), oldvaluekey, oldtypekey, valuekey, typekey;\n\t\tif(type===\"object\" && value) {\n\t\t\tif(typeof(value.__rrid__)===\"undefined\") {\n\t\t\t\tObject.defineProperty(value,\"__rrid__\",{value:uuid.v4()});\n\t\t\t}\n\t\t\tvaluekey = value.constructor.name + \"@\" + value.__rrid__;\n\t\t} else {\n\t\t\tvaluekey = value;\n\t\t}\n\t\tif(value===null || typeof(value)===\"undefined\") {\n\t\t\ttypekey = \"undefined\";\n\t\t} else {\n\t\t\ttypekey = type;\n\t\t}\n\t\tif(oldtype===\"object\" && oldValue) {\n\t\t\toldvaluekey = oldValue.constructor.name + \"@\" + oldValue.__rrid__;\n\t\t} else {\n\t\t\toldvaluekey = oldValue;\n\t\t}\n\t\tif(value===null || typeof(value)===\"undefined\") {\n\t\t\ttypekey = \"undefined\";\n\t\t} else {\n\t\t\ttypekey = type;\n\t\t}\n\t\tif(oldValue===null || typeof(oldValue)===\"undefined\") {\n\t\t\toldtypekey = \"undefined\";\n\t\t} else {\n\t\t\toldtypekey = oldtype;\n\t\t}\n\t\tindex[key][valuekey] = (index[key][valuekey] ? index[key][valuekey] : {});\n\t\tindex[key][valuekey][typekey] = (index[key][valuekey][typekey] ? index[key][valuekey][typekey] : {});\n\t\tindex[key][valuekey][typekey][instance.__rrid__] = instance;\n\t\tif(index[key][oldvaluekey] && index[key][oldvaluekey][oldtypekey]) {\n\t\t\tdelete index[key][oldvaluekey][oldtypekey][instance.__rrid__];\n\t\t}\n\t}\n\tfunction matchObject(index,instance,parentkeys,parentinstances) {\n\t\tif(!index) { return false; }\n\t\tvar\tkeys, primitive = false, instances;\n\t\tif(instance instanceof Number || instance instanceof String || instance instanceof Boolean || [\"number\",\"string\",\"boolean\"].indexOf(typeof(instance))>=0) {\n\t\t\tkeys = [\"value\"];\n\t\t\tprimitive = true;\n\t\t} else {\n\t\t\tkeys = Object.keys(instance);\n\t\t}\t\n\t\tparentkeys = (parentkeys ? parentkeys : []);\n\t\tparentinstances = (parentinstances ? parentinstances : []);\n\t\treturn keys.every(function(key) {\n\t\t\tif(!primitive && !index[key]) { return false; }\n\t\t\tvar value = (primitive ? instance.valueOf() : instance[key]), type = typeof(value), valuekey, typekey;\n\t\t\tif(type===\"object\" && value) {\n\t\t\t\tif(parentkeys.indexOf(key)>=0 && parentkeys.indexOf(key)===parentinstances.indexOf(value)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar valuekeys = Object.keys(index[key]);\n\t\t\t\treturn valuekeys.some(function(valuekey) {\n\t\t\t\t\tvar parts = valuekey.split(\"@\");\n\t\t\t\t\tif(parts.length!==2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar cons = Function(\"return \" + parts[0])();\n\t\t\t\t\tif(typeof(cons)!==\"function\" || !cons.index) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tparentkeys.push(key);\n\t\t\t\t\tparentinstances.push(value);\n\t\t\t\t\treturn matchObject(cons.index,value,parentkeys,parentinstances);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvaluekey = value;\n\t\t\t}\n\t\t\tif(value===null || typeof(value)===\"undefined\") {\n\t\t\t\ttypekey = \"undefined\";\n\t\t\t} else {\n\t\t\t\ttypekey = type;\n\t\t\t}\n\t\t\tif(!index[key][valuekey]) { return false; }\n\t\t\tif(!index[key][valuekey][typekey]) { return false; }\n\t\t\tif(instance.__rrid__ && !index[key][valuekey][typekey][instance.__rrid__]){  return false; }\n\t\t\tinstances = (instances ? intersection(instances,Object.keys(index[key][valuekey][typekey]))  : Object.keys(index[key][valuekey][typekey]));\n\t\t\treturn instances.length>0;\n\t\t});\n\t}\n\tfunction notMatchObject(index,instance,parentkeys,parentinstances) {\n\t\tif(!index) { return false; }\n\t\tvar\tprimitive = false;\n\t\tif(instance instanceof Number || instance instanceof String || instance instanceof Boolean || [\"number\",\"string\",\"boolean\"].indexOf(typeof(instance))>=0) {\n\t\t\tprimitive = true;\n\t\t}\t\n\t\tparentkeys = (parentkeys ? parentkeys : []);\n\t\tparentinstances = (parentinstances ? parentinstances : []);\n\t\treturn Object.keys(index).some(function(key) {\n\t\t\tvar value = (primitive ? instance.valueOf() : instance[key]), type = typeof(value);\n\t\t\tif(!primitive && typeof(instance[key])===\"undefined\") {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(type===\"object\" && value) {\n\t\t\t\tif(parentkeys.indexOf(key)>=0 && parentkeys.indexOf(key)===parentinstances.indexOf(value)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar valuekeys = Object.keys(index[key]);\n\t\t\t\treturn valuekeys.some(function(valuekey) {\n\t\t\t\t\tvar parts = valuekey.split(\"@\");\n\t\t\t\t\tif(parts.length!==2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar cons = Function(\"return \" + parts[0])();\n\t\t\t\t\tif(typeof(cons)!==\"function\" || !cons.index) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tparentkeys.push(key);\n\t\t\t\t\tparentinstances.push(value);\n\t\t\t\t\treturn notMatchObject(cons.index,value,parentkeys,parentinstances);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn Object.keys(index[key]).some(function(valuekey) {\n\t\t\t\tif(valuekey!==value+\"\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Object.keys(index[key][valuekey]).some(function(typekey) {\n\t\t\t\t\tif(typekey!==type) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\tfunction RuleReactor (domain,boost) {\n\t\tthis.boost = boost;\n\t\tthis.rules = {};\n\t\tthis.triggerlessRules = {};\n\t\tthis.data = new Map();\n\t\tthis.agenda = [];\n\t\tthis.run.assertions = 0;\n\t\tthis.run.modifications = 0;\n\t\tthis.run.executions = 0;\n\t\tthis.domain = (domain ? domain : {});\n\t}\n\tRuleReactor.prototype.assert = function(instances,callback) {\n\t\tvar me = this;\n\t\t// add instance to class.constructor.instances\n\t\tinstances = (Array.isArray(instances) || instances instanceof Array ? instances : [instances]);\n\t\tvar instancestoprocess = [];\n\t\tinstances.forEach(function(instance) {\n\t\t\t// don't bother processing instances that don't impact rules or are already in the data store\n\t\t\tif(instance && typeof(instance)===\"object\") { // !RuleReactor.data.has(instance)\n\t\t\t\tif(typeof(instance.__rrid__)===\"undefined\") {\n\t\t\t\t\tObject.defineProperty(instance,\"__rrid__\",{value:uuid.v4()});\n\t\t\t\t}\n\t\t\t\tif(me.data.has(instance.__rrid)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(me.tracelevel>2) {\n\t\t\t\t\tConsole.log(\"Assert: \",instance);\n\t\t\t\t}\n\t\t\t\tme.run.assertions++;\n\t\t\t\tme.data.set(instance.__rrid__,instance);\n\t\t\t\tme.dataModified = true;\n\t\t\t\tinstancestoprocess.push(instance);\n\t\t\t\t// fixes issue #21\n\t\t\t\tif ( !instance.constructor.hasOwnProperty('instances') ) instance.constructor.instances = [];\n\t\t\t\tif ( !instance.constructor.hasOwnProperty('index') ) instance.constructor.index = {};\n\t\t\t\t///instance.constructor.instances = (instance.constructor.instances ? instance.constructor.instances : []);\n\t\t\t\tinstance.constructor.instances.push(instance);\n\t\t\t\t//instance.constructor.index = (instance.constructor.index ? instance.constructor.index : {});\n\t\t\t\tindexObject(instance.constructor.index,instance);\n\t\t\t\t// patch any keys on instance or those identified as active while compiling\n\t\t\t\tvar keys = Object.keys(instance);\n\t\t\t\tif(instance.activeKeys) {\n\t\t\t\t\tObject.keys(instance.activeKeys).forEach(function(key) {\n\t\t\t\t\t\tif(keys.indexOf(key)===-1) {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tkeys.forEach(function(key) {\n\t\t\t\t\tfunction rrget() {\n\t\t\t\t\t\treturn rrget.value;\n\t\t\t\t\t}\n\t\t\t\t\tfunction rrset(value) {\n\t\t\t\t\t\tif(rrget.value!==value) {\n\t\t\t\t\t\t\tif(me.tracelevel>2) {\n\t\t\t\t\t\t\t\tConsole.log(\"Modify: \",instance,key,rrget.value,\"=>\",value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar oldvalue = rrget.value;\n\t\t\t\t\t\t\t// set new value\n\t\t\t\t\t\t\trrget.value = value;\n\t\t\t\t\t\t\tupdateIndex(instance.constructor.index,instance,key,oldvalue);\n\t\t\t\t\t\t\tme.dataModified = true; // may not have an impact\n\t\t\t\t\t\t\tme.run.modifications++;\n\t\t\t\t\t\t\t// if the value is an object that has possible rule matches, assert it\n\t\t\t\t\t\t\tif(value && value.rules) {\n\t\t\t\t\t\t\t\tme.assert(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// re-test the rules that pattern match the key\n\t\t\t\t\t\t\tif(instance.rules) { \n\t\t\t\t\t\t\t\tObject.keys(instance.rules).forEach(function(rulename) {\n\t\t\t\t\t\t\t\t\tvar rule = instance.rules[rulename];\n\t\t\t\t\t\t\t\t\tif(rule.triggers.some(function(trigger) {\n\t\t\t\t\t\t\t\t\t\treturn Object.keys(trigger.range).some(function(variable) {\n\t\t\t\t\t\t\t\t\t\t\treturn trigger.range[variable][key] && instance instanceof trigger.domain[variable];\n\t\t\t\t\t\t\t\t\t}); })) {\n\t\t\t\t\t\t\t\t\t\tvar activations = rule.activations.get(instance);\n\t\t\t\t\t\t\t\t\t\tif(activations) {\n\t\t\t\t\t\t\t\t\t\t\tactivations.forEach(function(activation) {\n\t\t\t\t\t\t\t\t\t\t\t\tactivation.cancel();\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\trule.test(instance,key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn rrget.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(instance,key);\n\t\t\t\t\tvar originalDescriptor;\n\t\t\t\t\tif(desc) {\n\t\t\t\t\t\toriginalDescriptor = {};\n\t\t\t\t\t\tObject.keys(desc).forEach(function(key) {\n\t\t\t\t\t\t\toriginalDescriptor[key] = desc[key];\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// create a new descriptor if one does not exist\n\t\t\t\t\tdesc = (desc ? desc : {enumerable:true,configurable:false});\n\t\t\t\t\tif(!desc.get || desc.get.name!==\"rrget\") {\n\t\t\t\t\t\t// rrget existing value\n\t\t\t\t\t\trrget.value = desc.value;\n\t\t\t\t\t\trrget.originalDescriptor = originalDescriptor;\n\t\t\t\t\t\t// modify arrays\n\t\t\t\t\t\tif(desc.value instanceof Array || Array.isArray(desc.value)) {\n\t\t\t\t\t\t\tvar value = desc.value;\n\t\t\t\t\t\t\toriginalDescriptor.value = value.slice();\n\t\t\t\t\t\t\tvar modifiers = [\"push\",\"pop\",\"splice\",\"shift\",\"unshift\"];\n\t\t\t\t\t\t\tmodifiers.forEach(function(fname) {\n\t\t\t\t\t\t\t\tvar f = value[fname];\n\t\t\t\t\t\t\t\tif(typeof(f)===\"function\") {\n\t\t\t\t\t\t\t\t\tvar newf = function() {\n\t\t\t\t\t\t\t\t\t\tf.apply(value,arguments);\n\t\t\t\t\t\t\t\t\t\tme.run.modifications++;\n\t\t\t\t\t\t\t\t\t\t// re-test the rules that pattern match the key\n\t\t\t\t\t\t\t\t\t\tObject.keys(instance.rules).forEach(function(rulename) {\n\t\t\t\t\t\t\t\t\t\t\tvar rule = instance.rules[rulename];\n\t\t\t\t\t\t\t\t\t\t\tif(rule.triggers.some(function(trigger) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn Object.keys(trigger.range).some(function(variable) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn trigger.range[variable][key] && instance instanceof trigger.domain[variable];\n\t\t\t\t\t\t\t\t\t\t\t});})) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar activations = rule.activations.get(instance);\n\t\t\t\t\t\t\t\t\t\t\t\tif(activations) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tactivations.forEach(function(activation) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tactivation.cancel();\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\trule.test(instance,key);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tObject.defineProperty(rrget.value,fname,{configurable:true,writable:true,value:newf});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tObject.getOwnPropertyNames(Array.prototype).forEach(function(fname) {\n\t\t\t\t\t\t\t\tvar f = value[fname];\n\t\t\t\t\t\t\t\tif(typeof(f)===\"function\" && modifiers.indexOf(fname)===-1) {\n\t\t\t\t\t\t\t\t\tObject.defineProperty(rrget.value,fname,{configurable:true,writable:true,value:function() {\n\t\t\t\t\t\t\t\t\t\treturn f.apply(value,arguments);\n\t\t\t\t\t\t\t\t\t}});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// delete descriptor properties that are inconsistent with rrget/rrset\n\t\t\t\t\t\tdelete desc.value;\n\t\t\t\t\t\tdelete desc.writable;\n\t\t\t\t\t\tdesc.get = rrget;\n\t\t\t\t\t\tdesc.set = rrset;\n\t\t\t\t\t\tObject.defineProperty(instance,key,desc);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tinstancestoprocess.forEach(function(instance) {\n\t\t\tif(instance.rules) {\n\t\t\t\tObject.keys(instance.rules).forEach(function(ruleinstance) {\n\t\t\t\t\tinstance.rules[ruleinstance].bind(instance);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t// test all associated rules\n\t\tinstancestoprocess.forEach(function(instance) {\n\t\t\tif(instance.rules) {\n\t\t\t\tObject.keys(instance.rules).forEach(function(rulename) {\n\t\t\t\t\tvar rule = instance.rules[rulename];\n\t\t\t\t\trule.test(instance);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tif(callback) {\n\t\t\tcallback(null);\n\t\t}\n\t}\n\tRuleReactor.prototype.createRule = function(name,salience,domain,condition,action) {\n\t\tvar me = this, rule = new Rule(this,name,salience,domain,condition,action,me.boost);\n\t\tme.rules[rule.name] = rule;\n\t\tif(rule.triggers.length===0) {\n\t\t\tme.triggerlessRules[rule.name] = rule;\n\t\t}\n\t\treturn rule;\n\t}\n\tRuleReactor.prototype.declare = function(domain,constructor) {\n\t\tif(typeof(module)===\"object\") {\n\t\t\tdomains[domain] = constructor;\n\t\t}\n\t}\n\tRuleReactor.forAll = function forAll(domain,test) {\n\t\tif(typeof(domain)!==\"object\") {\n\t\t\tthrow new TypeError(\"Domain \" + domain + \" is not an object in universal quantification\");\n\t\t}\n\t\tvar variables = Object.keys(domain);\n\t\tif(typeof(test)===\"object\") {\n\t\t\tif(!test) {\n\t\t\t\tthrow new TypeError(\"Universal quantification condition is null\");\n\t\t\t}\n\t\t\treturn Object.keys(test).every(function(variable) {\n\t\t\t\tvar i = variables.indexOf(variable);\n\t\t\t\tif(i===-1) {\n\t\t\t\t\tthrow new ReferenceError(\"Undeclared domain variable '\" + variable + \"' in existential quantification match condition\");\n\t\t\t\t}\n\t\t\t\treturn !notMatchObject(domain[variable].index,test[variable]);\n\t\t\t});\n\t\t}\n\t\tif((test+\"\").indexOf(\"return \")===-1) {\n\t\t\tthrow new TypeError(\"Universal quantification condition function missing a return statement: \" + test);\n\t\t}\n\t\tif(!test.cxproduct) {\n\t\t\tvar collections = [], args;\n\t\t\tvariables.forEach(function(variable) {\n\t\t\t\t// fixes issue #21\n\t\t\t\tif ( !domain[variable].hasOwnProperty('instances') ) domain[variable].instances = [];\n\t\t\t\tif ( !domain[variable].hasOwnProperty('index') ) domain[variable].index = {};\n\t\t\t\t//domain[variable].instances = (domain[variable].instances ? domain[variable].instances: []);\n\t\t\t\tcollections.push(domain[variable].instances);\n\t\t\t});\n\t\t\ttest.cxproduct = new CXProduct(collections);\n\t\t\targs = getFunctionArgs(test);\n\t\t\tif(args.length>0) {\n\t\t\t\ttest.required = args.map(function(variable) { \n\t\t\t\t\tvar i = variables.indexOf(variable);\n\t\t\t\t\tif(i===-1) {\n\t\t\t\t\t\tthrow new ReferenceError(\"Undeclared domain variable '\" + variable + \"' in universal quantification condition function\");\n\t\t\t\t\t}\n\t\t\t\t\treturn i; \n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn test.cxproduct.every(function(row) {\n\t\t\tvar args = [];\n\t\t\tif(!test.required || test.required.every(function(index) { args.push(row[index]); return typeof(row[index])!==\"undefined\"; })) {\n\t\t\t\treturn test.apply(null,args);\n\t\t\t}\n\t\t});\n\t}\n\tRuleReactor.prototype.forAll  = RuleReactor.forAll;\n\tRuleReactor.exists = function exists(domain,test) {\n\t\tif(typeof(domain)!==\"object\") {\n\t\t\tthrow new TypeError(\"Domain \" + domain + \" is not an object in existential quantification\");\n\t\t}\n\t\tvar variables = Object.keys(domain);\n\t\tif(typeof(test)===\"object\") {\n\t\t\tif(!test) {\n\t\t\t\tthrow new TypeError(\"Existential quantification condition is null\");\n\t\t\t}\n\t\t\treturn Object.keys(test).every(function(variable) {\n\t\t\t\tvar i = variables.indexOf(variable);\n\t\t\t\tif(i===-1) {\n\t\t\t\t\tthrow new ReferenceError(\"Undeclared domain variable '\" + variable + \"' in existential quantification match condition\");\n\t\t\t\t}\n\t\t\t\treturn matchObject(domain[variable].index,test[variable]);\n\t\t\t});\n\t\t}\n\t\tif((test+\"\").indexOf(\"return \")===-1) {\n\t\t\tthrow new TypeError(\"Existential quantification condition function missing a return statement: \" + test);\n\t\t}\n\t\tif(!test.cxproduct) {\n\t\t\tvar collections = [], args;\n\t\t\tvariables.forEach(function(variable) {\n\t\t\t\t// fixes issue #21\n\t\t\t\tif ( !domain[variable].hasOwnProperty('instances') ) domain[variable].instances = [];\n\t\t\t\tif ( !domain[variable].hasOwnProperty('index') ) domain[variable].index = {};\n\t\t\t\t//domain[variable].instances = (domain[variable].instances ? domain[variable].instances: []);\n\t\t\t\tcollections.push(domain[variable].instances);\n\t\t\t});\n\t\t\ttest.cxproduct = new CXProduct(collections);\n\t\t\targs = getFunctionArgs(test);\n\t\t\tif(args.length>0) {\n\t\t\t\ttest.required = args.map(function(variable) { \n\t\t\t\t\tvar i = variables.indexOf(variable);\n\t\t\t\t\tif(i===-1) {\n\t\t\t\t\t\tthrow new ReferenceError(\"Undeclared domain variable '\" + variable + \"' in existential quantification condition function\");\n\t\t\t\t\t}\n\t\t\t\t\treturn i; \n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn test.cxproduct.some(function(row) {\n\t\t\tvar args = [];\n\t\t\tif(!test.required || test.required.every(function(index) { args.push(row[index]); return typeof(row[index])!==\"undefined\"; })) {\n\t\t\t\treturn test.apply(null,args);\n\t\t\t}\n\t\t});\n\t}\n\tRuleReactor.prototype.exists = RuleReactor.exists;\n\tRuleReactor.not = function not(value) {\n\t\treturn !value;\n\t}\n\tRuleReactor.prototype.not = RuleReactor.not;\n\tRuleReactor.prototype.retract = function(instances,run) {\n\t\tvar me = this;\n\t\tinstances = (Array.isArray(instances) || instances instanceof Array ? instances : [instances]);\n\t\tinstances.forEach(function(instance) {\n\t\t\tif(instance && typeof(instance)===\"object\") {\n\t\t\t\tif(me.tracelevel>2) {\n\t\t\t\t\tConsole.log(\"Retract: \",instance);\n\t\t\t\t}\n\t\t\t\t// retract from data\n\t\t\t\tme.data.delete(instance.__rrid__);\n\t\t\t\tme.dataModified = true;\n\t\t\t\t// restore instance properties\n\t\t\t\tObject.keys(instance).forEach(function(key) {\n\t\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(instance,key);\n\t\t\t\t\tif(desc.get && desc.get.name===\"rrget\") {\n\t\t\t\t\t\tif(typeof(desc.get.originalDescriptor)===\"undefined\") {\n\t\t\t\t\t\t\tdelete instance[key];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(desc.get.originalDescriptor.value instanceof Array || Array.isArray(desc.get.originalDescriptor.value)) {\n\t\t\t\t\t\t\t\tif(instance[key] instanceof Array || Array.isArray(instance[key])) {\n\t\t\t\t\t\t\t\t\tvar args = [0,instance[key]].concat(desc.get.originalDescriptor.value);\n\t\t\t\t\t\t\t\t\tinstance[key].splice.apply(instance[key],args);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinstance[key] = desc.get.originalDescriptor.value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tObject.defineProperty(instance,key,desc.get.originalDescriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// unbind from all associated rules\n\t\t\t\tObject.keys(instance.rules).forEach(function(rulename) {\n\t\t\t\t\tinstance.rules[rulename].unbind(instance);\n\t\t\t\t});\n\n\t\t\t}\n\t\t});\n\t\tif(run) {\n\t\t\tsetTimeout(function() { me.run(); });\n\t\t}\n\t}\n\tRuleReactor.prototype.reset = function(facts) {\n\t\tvar me = this;\n\t\tObject.keys(me.rules).forEach(function(rulename) {\n\t\t\tme.rules[rulename].reset();\n\t\t});\n\t\tif(facts) {\n\t\t\tvar data = [];\n\t\t\tme.data.forEach(function(instance) {\n\t\t\t\tdata.push(instance);\n\t\t\t});\n\t\t\tme.retract(data,false);\n\t\t}\n\t\tme.run.running = false;\n\t}\n\tRuleReactor.prototype.run = function(max,loose,callback) {\n\t\tvar me = this;\n\t\tfunction run() {\n\t\t\tif(me.run.stop) {\n\t\t\t\tif(me.tracelevel>0) {\n\t\t\t\t\tConsole.log(\"Data Count: \",me.data.size);\n\t\t\t\t\tConsole.log(\"Executions: \",me.run.executions);\n\t\t\t\t\tConsole.log(\"RPS: \",me.run.rps);\n\t\t\t\t}\n\t\t\t\tif(me.tracelevel>1) {\n\t\t\t\t\tObject.keys(me.rules).forEach(function(rulename) {\n\t\t\t\t\t\tvar rule = me.rules[rulename];\n\t\t\t\t\t\tConsole.log(rule.name,rule.potentialMatches,rule.tested,rule.activated,rule.fired);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif(typeof(callback)===\"function\") {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(me.run.executions<me.run.max) {\n\t\t\t\tObject.keys(me.triggerlessRules).forEach(function(rulename) {\n\t\t\t\t\tvar rule = me.triggerlessRules[rulename], activations = rule.activations.get(); // get's activations associated with undefined domains\n\t\t\t\t\tif(!activations || activations.length===0) {\n\t\t\t\t\t\trule.test();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\twhile (me.agenda.length>0) {\n\t\t\t\t\tme.dataModified = false;\n\t\t\t\t\tme.agenda[me.agenda.length-1].execute(me.agenda.length-1);\n\t\t\t\t\tif(me.dataModified) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetTimeout(run,0);\n\t\t}\n\t\tif(me.run.running) { return true; }\n\t\tme.run.max = (max ? max : Infinity);\n\t\tme.run.running = true;\n\t\tme.run.executions = 0;\n\t\tme.run.assertions = 0;\n\t\tme.run.modifications = 0;\n\t\tme.run.start = new Date();\n\t\tme.run.stop = null;\n\t\tif(me.tracelevel>0) {\n\t\t\tConsole.log(\"Run: \",max);\n\t\t}\n\t\tsetTimeout(run,0);\n\t}\n\tRuleReactor.prototype.stop = function() {\n\t\tthis.run.stop = new Date();\n\t\tthis.run.rps = (this.run.executions / (this.run.stop.getTime() - this.run.start.getTime())) * 1000;\n\t\tthis.run.running = false;\n\t}\n\tRuleReactor.prototype.trace = function(level) {\n\t\tthis.tracelevel = level;\n\t\tif(this.processor) {\n\t\t\tif(level>3) {\n\t\t\t\tthis.processor.trace(1);\n\t\t\t} else {\n\t\t\t\tthis.processor.trace(0);\n\t\t\t}\n\t\t}\t\n\t}\n\n\tif (this.exports) {\n\t\tthis.exports  = RuleReactor;\n\t} else if (typeof define === \"function\" && define.amd) {\n\t\t// Publish as AMD module\n\t\tdefine(function() {return RuleReactor;});\n\t} else {\n\t\tthis.RuleReactor = RuleReactor;\n\t}\n}).call((typeof(window)!==\"undefined\" ? window : (typeof(module)!==\"undefined\" ? module : null)));\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"uuid\":3}],2:[function(require,module,exports){\n(function (global){\n\nvar rng;\n\nif (global.crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],3:[function(require,module,exports){\n//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n\n},{\"./rng\":2}]},{},[1]);\n"}